{"version":3,"file":"nix-sdk.umd.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/constants.js","../src/util.js","../src/JWS.js","../src/JWK.js","../src/JWE.js","../src/JWT.js","../src/IdentityCommsResponse.js","../src/IdentityCommsMessage.js","../src/IdentityMetaPublic.js","../src/IdentityMetaPrivate.js","../src/IdentityComms.js","../src/ContentPackage.js","../src/Identity.js","../node_modules/idb/build/esm/chunk.js","../node_modules/idb/build/esm/index.js","../src/Vault.js","../src/VaultManager.js","../src/Client.js","../src/LocalEncryptedStore.js","../src/RecoveryAndLocalEncryptedStore.js","../src/index.js"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && !check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, value);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\t_entry(_this).then(returnValue, function(error) {\n\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","\n// IdentityTypes\nexport const IdentityTypeUnknown = \"\";\nexport const IdentityTypeApp     = \"app\";\nexport const IdentityTypeGroup   = \"group\";\nexport const IdentityTypeRoute   = \"route\";\nexport const IdentityTypeUser    = \"user\";\nexport const IdentityTypeVault   = \"vault\";\n\n// JWS / JWE KID Thumb length\nexport const KIDThumbLength = 8;\n\n// Identity Msg Types\nexport const IdentityMsgType = {\n  Signed:     \"s\",\n  Encrypted:  \"e\",\n  Request:    \"r\",\n  Publish:    \"p\",\n  Clear:      \"c\",\n};\n\n// Vault Operations / Permissions\nexport const VaultOps = {\n  ContentPkgRead:    \"pr\",\n  ContentPkgWrite:   \"pw\",\n  ContentPkgControl: \"pc\",\n\n  IdentitiesRead:    \"ir\",\n  IdentitiesWrite:   \"iw\",\n  IdentitiesControl: \"ic\",\n\n  VaultRead:    \"vr\",\n  VaultWrite:   \"vw\",\n  VaultControl: \"vc\",\n};\n\nexport const JWERegex = /(ey[0-9A-Za-z_\\-]*\\.[0-9A-Za-z_\\-]*\\.[0-9A-Za-z_\\-]*\\.[0-9A-Za-z_\\-]*\\.[0-9A-Za-z_\\-]*)/g;\n","export function base64EncodeStr(str) {\n  return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function(match, p1) {\n    return String.fromCharCode('0x' + p1);\n  }));\n}\n\nexport function base64EncodeStrJWS(str) {\n  return base64EncodeStr(str).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\nexport function base64EncodeBytes(str) {\n  return btoa(str);\n}\n\nexport function base64EncodeBytesURL(str) {\n  return btoa(str).replace(/\\+/g, '-').replace(/\\//g, '_');\n}\n\nexport function base64EncodeBytesJWS(str) {\n  return base64EncodeBytes(str).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\nexport function base64DecodeStr(str) {\n  return decodeURIComponent(atob(str).split('').map(function(c) {\n    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n  }).join(''));\n}\n\nexport function base64DecodeStrJWS(str) {\n  return base64DecodeStr(str.replace(/-/g, '+').replace(/_/g, '/'));\n}\n\nexport function base64DecodeBytes(str) {\n  return atob(str);\n}\n\nexport function base64DecodeBytesJWS(str) {\n  return base64DecodeBytes(str.replace(/-/g, '+').replace(/_/g, '/'));\n}\n\nexport function strToUtf8ArrayBuf(str) {\n  str = encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function(match, p1) {\n    return String.fromCharCode('0x' + p1);\n  });\n  return bytesToUint8ArrayBuf(str);\n}\n\nexport function strToBytes(str) {\n  return encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function(match, p1) {\n    return String.fromCharCode('0x' + p1);\n  });\n}\n\nexport function bytesToUint8ArrayBuf(str) {\n  return bytesToUint8Array(str).buffer;\n}\n\nexport function bytesToUint8Array(str) {\n  var arr = new Uint8Array(str.length);\n  for(var i = 0; i < str.length; i++) {\n    arr[i] = str.charCodeAt(i);\n  }\n  return arr;\n}\n\nexport async function b64UUID() {\n  var array = new Uint8Array(16);\n  await crypto.getRandomValues(array);\n  return base64EncodeBytesJWS(arrToBytes(array));\n}\n\nexport function bytesToLenPrefixUint8Array(str) {\n  var arr = new Uint8Array(str.length + 4);\n  arr[0] = (str.length >>> 24) & 0xFF;\n  arr[1] = (str.length >>> 16) & 0xFF;\n  arr[2] = (str.length >>> 8 ) & 0xFF;\n  arr[3] = (str.length >>> 0 ) & 0xFF;\n  for(var i = 0; i < str.length; i++) {\n    arr[i+4] = str.charCodeAt(i);\n  }\n  return arr;\n}\n\nexport function errPromise(val) {\n  return new Promise((resolve, reject) =>\n    { reject(val); });\n}\n\nexport function successPromise(val) {\n  return new Promise((resolve, reject) =>\n    { resolve(val); });\n}\n\nexport function jwkThumbSHA256B64(jwk) {\n  if(jwk.kty !== \"EC\" || jwk.crv !== \"P-256\") {\n    return errPromise(`unsupported key - only ES256 - ${jwk.kty} ${jwk.crv}`);\n  }\n\n  return crypto.subtle.digest({name: \"SHA-256\"},\n    bytesToUint8ArrayBuf(`{\"crv\":\"P-256\",\"kty\":\"EC\",\"x\":\"${jwk.x}\",\"y\":\"${jwk.y}\"}`))\n    .then((hash) => base64EncodeBytesURL(arrToBytes(hash)));\n}\n\nexport function arrToBytes(arr) {\n  var out = '';\n  var u8arr = new Uint8Array(arr);\n  var len = u8arr.byteLength;\n  for (var i = 0; i < len; i++) {\n    out += String.fromCharCode(u8arr[i]);\n  }\n  return out;\n}\n\nexport function arrToStr(arr) {\n  return decodeURIComponent(arrToBytes(arr).split('').map(function(c) {\n    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n  }).join(''));\n}\n\nexport function trimAddr(addr) {\n  var path = \"\";\n  var host = \"\";\n  var user = \"\";\n\n  var firstSlash = addr.indexOf('/');\n  var userHost = addr;\n  if(firstSlash >= 0) {\n    userHost = addr.slice(0, firstSlash);\n    path = addr.slice(firstSlash);\n  }\n\n  var firstAt = userHost.indexOf('@');\n  user = userHost;\n  if(firstAt >= 0) {\n    user = userHost.slice(0, firstAt).replace(/=/g, '');\n    host = userHost.slice(firstAt);\n  }\n\n  // addresses without a host are asumed to be api.nix.software\n  if(host === \"@api.nix.software\") {\n    host = \"\";\n  }\n\n  return user + host + path;\n}\n\nexport function kidToCanonUserHostPath(addr) {\n  let path = '';\n  let userHost = addr;\n  let firstSlash = addr.indexOf('/');\n  if(firstSlash >= 0) {\n    userHost = addr.slice(0, firstSlash);\n    path = addr.slice(firstSlash+1);\n  }\n\n  let firstAt = userHost.indexOf('@');\n  var user = userHost;\n  var host = \"@api.nix.software\";\n  if(firstAt >= 0) {\n    user = userHost.slice(0, firstAt);\n    host = userHost.slice(firstAt);\n  }\n  // is user portion potentially unpadded? length-1 for leading type char\n  if(user.length && user[user.length-1] != '=') {\n    switch(user.length-1 % 4) {\n      case 2:\n        user += \"==\";\n        break;\n      case 3:\n        user += \"=\";\n        break;\n      default:\n        // 0, 4 have no padding\n        break;\n    }\n  }\n  return [user + host, path];\n}\n\nexport function kidStripHostPath(addr) {\n  let path = addr;\n  let firstSlash = addr.indexOf('/');\n  if(firstSlash >= 0) {\n    path = addr.slice(firstSlash+1);\n  }\n  return path;\n}\n","import {\n  base64EncodeStrJWS, base64EncodeBytesJWS,\n  base64DecodeStrJWS, base64DecodeBytesJWS,\n  bytesToUint8ArrayBuf, arrToBytes,\n  errPromise, successPromise,\n} from './util.js';\n\nexport default class JWS {\n  constructor() {\n    this.rawCompact = null;\n\n    this.headerB64    = null;\n    this.payloadB64   = null;\n    this.signatureB64 = null;\n\n    this.payload = null;\n\n    this.alg = null;\n    this.jwk = null;\n    this.kid = null;\n    this.tgt = null;\n    this.iat = 0;\n    this.typ = null;\n    this.cty = null;\n  }\n\n  static fromCompact(str) {\n    let jws = new JWS();\n    jws.rawCompact = str;\n    [jws.headerB64, jws.payloadB64, jws.signatureB64] = str.split(\".\", 3);\n    let head = JSON.parse(base64DecodeStrJWS(jws.headerB64));\n    [jws.alg, jws.jwk, jws.kid, jws.tgt, jws.iat, jws.typ, jws.cty] = \n      [head.alg, head.jwk, head.kid, head.tgt, head.iat, head.typ, head.cty];\n\n    return jws;\n  }\n\n  static forJSONPayload(jsonStr) {\n    let jws = new JWS();\n    jws.payload = jsonStr;\n    return jws;\n  }\n\n  static forValuePayload(val) {\n    return JWS.forJSONPayload(JSON.stringify(val));\n  }\n\n  setTgtIat(tgt) {\n    this.iat = (Date.now() / 1000) | 0;\n    this.tgt = tgt;\n    return this;\n  }\n\n  setKID(kid) {\n    this.kid = kid;\n    return this;\n  }\n\n  async verify(pubKeyHandle) {\n    if(this.alg !== \"ES256\") {\n      return errPromise(\"unsupported alg - only ES256 supported\");\n    }\n\n    if(pubKeyHandle.algorithm.name !== \"ECDSA\" || pubKeyHandle.algorithm.namedCurve !== \"P-256\") {\n      return errPromise(`unsupported key - only ES256 - ${JSON.stringify(pubKeyHandle.algorithm)}`);\n    }\n\n    let payload = bytesToUint8ArrayBuf(this.headerB64 + \".\" + this.payloadB64);\n    return await crypto.subtle.verify(\n      {name: \"ECDSA\", hash: {name: \"SHA-256\"}},\n      pubKeyHandle,\n      bytesToUint8ArrayBuf(base64DecodeBytesJWS(this.signatureB64)),\n      payload)\n    .then((isValid) => isValid ? successPromise(this.UNSAFEExtractPayload()) : errPromise(`signature invalid for ${JSON.stringify(this)}`))\n    .catch((err) => errPromise(err));\n  }\n\n  toLogFormat() {\n    return {\n      payload: JSON.parse(base64DecodeStrJWS(this.payloadB64)),\n      protected: JSON.parse(base64DecodeStrJWS(this.headerB64)),\n      signature: this.signatureB64,\n    };\n  }\n\n  UNSAFEExtractPayload() {\n    return base64DecodeStrJWS(this.payloadB64);\n  }\n\n  async toCompactECDSAP256(privKeyHandle) {\n    if(privKeyHandle.algorithm.name !== \"ECDSA\" || privKeyHandle.algorithm.namedCurve !== \"P-256\") {\n      return errPromise(`unsupported key - only ES256 - ${JSON.stringify(privKeyHandle.algorithm)}`);\n    }\n\n    this.alg = \"ES256\";\n\n    let headerObj = {\n      alg: this.alg,\n      jwk: this.jwk,\n      kid: this.kid,\n      tgt: this.tgt,\n      iat: this.iat,\n      typ: this.typ,\n      cty: this.cty,\n    };\n    Object.keys(headerObj).forEach(k => (!headerObj[k] && !headerObj[k] !== undefined) && delete headerObj[k]);\n    this.headerB64 = base64EncodeStrJWS(JSON.stringify(headerObj));\n\n    this.payloadB64 = base64EncodeStrJWS(this.payload);\n\n    let toSign = bytesToUint8ArrayBuf(this.headerB64 + \".\" + this.payloadB64);\n    let signature = await crypto.subtle.sign(\n      {name: \"ECDSA\", hash: {name: \"SHA-256\"}},\n      privKeyHandle,\n      toSign);\n\n    this.signatureB64 = base64EncodeBytesJWS(arrToBytes(signature));\n    return [this.headerB64, this.payloadB64, this.signatureB64].join(\".\");\n  }\n};\n","import {jwkThumbSHA256B64} from './util.js';\n\nexport default class JWK {\n  constructor() {\n    // shouldn't be called dirctly\n  }\n\n  static async toECDSAP256Pub(jwk) {\n    jwk = Object.assign({}, jwk);\n    delete jwk.use;\n    delete jwk.d;\n    return await crypto.subtle.importKey(\n      \"jwk\", jwk, {name: \"ECDSA\", namedCurve: \"P-256\"}, true, [\"verify\"]);\n  }\n\n  static async toECDSAP256Priv(jwk) {\n    jwk = Object.assign({}, jwk);\n    delete jwk.use;\n    return crypto.subtle.importKey(\n      \"jwk\", jwk, {name: \"ECDSA\", namedCurve: \"P-256\"}, true, [\"sign\"]);\n  }\n\n  static async toECDHP256Pub(jwk) {\n    jwk = Object.assign({}, jwk);\n    delete jwk.use;\n    delete jwk.d;\n    return await crypto.subtle.importKey(\n      \"jwk\", jwk, {name: \"ECDH\", namedCurve: \"P-256\"}, true, []);\n  }\n\n  static async toECDHP256Priv(jwk) {\n    jwk = Object.assign({}, jwk);\n    delete jwk.use;\n    return await crypto.subtle.importKey(\n      \"jwk\", jwk, {name: \"ECDH\", namedCurve: \"P-256\"}, true, [\"deriveKey\"]);\n  }\n\n  static async toAESGCMKey(jwk) {\n    jwk = Object.assign({}, jwk);\n    delete jwk.use;\n    return await crypto.subtle.importKey(\"jwk\", jwk, {name: \"AES-GCM\"}, true, [\"encrypt\", \"decrypt\"]);\n  }\n\n  static async randomAESGCM() {\n    const rawKey = crypto.getRandomValues(new Uint8Array(32));\n    return crypto.subtle.exportKey(\"jwk\", \n      await crypto.subtle.importKey(\"raw\", rawKey, \"AES-GCM\", true, [\"encrypt\", \"decrypt\"]));\n  }\n\n  static async fromECDSAP256Pub(key) {\n    let sigPubKey = await crypto.subtle.exportKey(\"jwk\", key);\n    delete sigPubKey.d;\n    delete sigPubKey.ext;\n    delete sigPubKey.key_ops;\n    sigPubKey.use = \"sig\";\n    sigPubKey.kid = await jwkThumbSHA256B64(sigPubKey);\n    return sigPubKey;\n  }\n\n\n  static async fromECDSAP256Priv(key) {\n    let sigPrivKey = await crypto.subtle.exportKey(\"jwk\", key);\n    delete sigPrivKey.ext;\n    delete sigPrivKey.key_ops;\n    sigPrivKey.use = \"sig\";\n    sigPrivKey.kid = await jwkThumbSHA256B64(sigPrivKey);\n    return sigPrivKey;\n  }\n\n  static async fromECDHP256Pub(key) {\n    let encPubKey = await crypto.subtle.exportKey(\"jwk\", key);\n    delete encPubKey.d;\n    delete encPubKey.ext;\n    delete encPubKey.key_ops;\n    encPubKey.use = \"enc\";\n    encPubKey.kid = await jwkThumbSHA256B64(encPubKey);\n    return encPubKey;\n  }\n\n  static async fromECDHP256Priv(key) {\n    let encPrivKey = await crypto.subtle.exportKey(\"jwk\", key);\n    delete encPrivKey.ext;\n    delete encPrivKey.key_ops;\n    encPrivKey.use = \"enc\";\n    encPrivKey.kid = await jwkThumbSHA256B64(encPrivKey);\n    return encPrivKey;\n  }\n}\n","import {\n  base64EncodeStrJWS,\n  base64EncodeBytesJWS,\n  base64DecodeStrJWS,\n  base64DecodeBytesJWS,\n  strToUtf8ArrayBuf,\n  arrToBytes,\n  arrToStr,\n  bytesToUint8ArrayBuf,\n  bytesToLenPrefixUint8Array,\n} from './util.js';\nimport JWK from './JWK.js';\n\nexport default class JWE {\n  constructor() {\n    this.protectedB64 = null;\n    this.encryptedKey = null;\n    this.iv           = null;\n    this.cipherText   = null;\n    this.tag          = null;\n  }\n\n  getProtected() {\n    return JSON.parse(base64DecodeStrJWS(this.protectedB64));\n  }\n\n  static fromCompact(str) {\n    let jwe = new JWE();\n    let parts = str.split(\".\", 5);\n    jwe.protectedB64 = parts[0];\n    jwe.iv = bytesToUint8ArrayBuf(base64DecodeBytesJWS(parts[2]));\n    jwe.cipherText = bytesToUint8ArrayBuf(base64DecodeBytesJWS(parts[3]));\n    jwe.tag = bytesToUint8ArrayBuf(base64DecodeBytesJWS(parts[4]));\n\n    return jwe;\n  }\n\n  toLogFormat(payload) {\n    return {\n      payload: payload,\n      protected: JSON.parse(base64DecodeStrJWS(this.protectedB64)),\n    };\n  }\n\n  static async encryptECDHESP256(pub, payload, kid, protectedObj) {\n    let out = new JWE();\n\n    if(pub.algorithm.name !== \"ECDH\" || pub.algorithm.namedCurve !== \"P-256\") {\n      throw `unsupported key - only ECDH-ES P-256- ${JSON.stringify(pub.algorithm)}`;\n    }\n\n    let ephemeralPair = await crypto.subtle.generateKey(\n      {name: \"ECDH\", namedCurve: \"P-256\"}, true, [\"deriveKey\"]);\n\n    let ephemeralPubKeyJWK = await crypto.subtle.exportKey(\"jwk\", ephemeralPair.publicKey);\n    delete ephemeralPubKeyJWK.ext;\n    delete ephemeralPubKeyJWK.key_ops;\n    ephemeralPubKeyJWK.use = \"enc\";\n\n    protectedObj = protectedObj || {};\n    protectedObj.alg = \"ECDH-ES\";\n    protectedObj.enc = \"A256GCM\";\n    protectedObj.epk = ephemeralPubKeyJWK;\n\n    if(kid) {\n      protectedObj.kid = kid;\n    }\n\n    out.protectedB64 = base64EncodeStrJWS(JSON.stringify(protectedObj));\n\n    let key = await crypto.subtle.deriveKey(\n      {name: \"ECDH\", namedCurve: \"P-256\", public: pub},\n      ephemeralPair.privateKey,\n      {name: \"AES-GCM\", length: 256},\n      true,\n      [\"encrypt\", \"decrypt\"]);\n\n    key = await JWE.deriveKeyConcatKDFSHA256(\"A256GCM\", \"\", \"\", key)\n\n    out.iv = await crypto.getRandomValues(new Uint8Array(12));\n    out.cipherText = new Uint8Array(await crypto.subtle.encrypt(\n      {name: \"AES-GCM\", iv: out.iv, additionalData: bytesToUint8ArrayBuf(out.protectedB64), tagLength: 128},\n      key,\n      strToUtf8ArrayBuf(payload)));\n\n    out.tag = out.cipherText.slice(out.cipherText.byteLength - 16);\n    out.cipherText = out.cipherText.slice(0, out.cipherText.byteLength - 16);\n\n    return out;\n  }\n\n  static async encryptPBKDF2AES256GCM(password, salt, payload, kid, protectedObj) {\n    return await JWE.encryptDirectAES256GCM(await JWE.pbkdf2(password, salt), payload, kid, protectedObj);\n  }\n\n  static async encryptDirectAES256GCM(key, payload, kid, protectedObj) {\n    let out = new JWE();\n\n    // check for JWK instead of raw key\n    if(key.kty === \"oct\") {\n      key = await JWK.toAESGCMKey(key);\n    }\n\n    if(key.algorithm.name !== \"AES-GCM\" || key.algorithm.length !== 256) {\n      throw `unsupported key - only AES-GCM 256 - ${JSON.stringify(key.algorithm)}`;\n    }\n\n    protectedObj = protectedObj || {};\n    protectedObj.alg =  \"dir\";\n    protectedObj.enc = \"A256GCM\";\n\n    if(kid) {\n      protectedObj.kid = kid;\n    }\n\n    out.protectedB64 = base64EncodeStrJWS(JSON.stringify(protectedObj));\n\n    out.iv = await crypto.getRandomValues(new Uint8Array(12));\n\n    out.cipherText = new Uint8Array(await crypto.subtle.encrypt(\n      {name: \"AES-GCM\", iv: out.iv, additionalData: bytesToUint8ArrayBuf(out.protectedB64), tagLength: 128},\n      key,\n      strToUtf8ArrayBuf(payload)));\n\n    out.tag = out.cipherText.slice(out.cipherText.byteLength - 16);\n    out.cipherText = out.cipherText.slice(0, out.cipherText.byteLength - 16);\n\n    return out;\n  }\n\n  static async pbkdf2(password, salt) {\n    return await crypto.subtle.deriveKey(\n      {name: \"PBKDF2\", salt: strToUtf8ArrayBuf(salt), iterations: 10000, hash: {name: \"SHA-256\"}},\n      await crypto.subtle.importKey(\"raw\", strToUtf8ArrayBuf(password), {name: \"PBKDF2\"}, false, [\"deriveKey\", \"deriveBits\"]),\n      {name: \"AES-GCM\", length: 256},\n      true,\n      [\"encrypt\", \"decrypt\"]);\n  }\n\n  // algID, apu, and apv should be raw byte arrays, zx should be the ECDH output\n  static async deriveKeyConcatKDFSHA256(algID, apu, apv, zx) {\n    algID = bytesToLenPrefixUint8Array(algID);\n    apu   = bytesToLenPrefixUint8Array(apu);\n    apv   = bytesToLenPrefixUint8Array(apv);\n\n    // 256\n    let subPubInfo = new Uint8Array(4);\n    subPubInfo[0] = 0;\n    subPubInfo[1] = 0;\n    subPubInfo[2] = 1;\n    subPubInfo[3] = 0;\n\n    // 1\n    let round = new Uint8Array(4);\n    round[0] = 0;\n    round[1] = 0;\n    round[2] = 0;\n    round[3] = 1;\n\n    zx = new Uint8Array(await crypto.subtle.exportKey(\"raw\", zx));\n\n    let data = new Uint8Array(\n      round.length + zx.length + algID.length + apu.length + apv.length + subPubInfo.length);\n\n    let offset = 0;\n    data.set(round, offset);\n    offset += round.length;\n    data.set(zx, offset);\n    offset += zx.length;\n    data.set(algID, offset);\n    offset += algID.length;\n    data.set(apu, offset);\n    offset += apu.length;\n    data.set(apv, offset);\n    offset += apv.length;\n    data.set(subPubInfo, offset);\n\n    let key = await crypto.subtle.digest({name: \"SHA-256\"}, data);\n    return await crypto.subtle.importKey(\"raw\", key, {name: \"AES-GCM\"}, true, [\"encrypt\", \"decrypt\"]);\n  }\n\n  toCompact() {\n    return `${this.protectedB64}..${base64EncodeBytesJWS(arrToBytes(this.iv))}.` + \n      `${base64EncodeBytesJWS(arrToBytes(this.cipherText))}.${base64EncodeBytesJWS(arrToBytes(this.tag))}`;\n  }\n\n  async decryptECDHEP256(priv) {\n    let prot = JSON.parse(base64DecodeStrJWS(this.protectedB64));\n    if(prot.alg !== \"ECDH-ES\" || prot.enc !== \"A256GCM\") {\n      throw `unsupported alg + enc - only ECDH-ES with A256GCM - ${prot.alg} ${prot.enc}`;\n    }\n\n    let ephemeralPublic = await JWK.toECDHP256Pub(prot.epk);\n\n    let key = await crypto.subtle.deriveKey(\n      {name: \"ECDH\", namedCurve: \"P-256\", public: ephemeralPublic},\n      priv,\n      {name: \"AES-GCM\", length: 256},\n      true,\n      [\"encrypt\", \"decrypt\"]);\n\n    let apu = prot.apu ? base64DecodeBytesJWS(prot.apu) : \"\";\n    let apv = prot.apv ?  base64DecodeBytesJWS(prot.apv) : \"\";\n\n    key = await JWE.deriveKeyConcatKDFSHA256(\"A256GCM\", apu, apv, key)\n\n    let dataLen = this.cipherText.byteLength + this.tag.byteLength;\n    let data = new Uint8Array(dataLen);\n    data.set(new Uint8Array(this.cipherText), 0);\n    data.set(new Uint8Array(this.tag), dataLen - 16);\n\n    return arrToStr(await crypto.subtle.decrypt(\n      {name: \"AES-GCM\", iv: this.iv, additionalData: bytesToUint8ArrayBuf(this.protectedB64), tagLength: 128},\n      key,\n      data));\n  }\n\n  async decryptPBKDF2AES256GCM(password, salt) {\n    return await this.decryptDirectAES256GCM(await JWE.pbkdf2(password, salt));\n  }\n\n  async decryptDirectAES256GCM(key) {\n    // check for JWK instead of raw key\n    if(key.kty === \"oct\") {\n      key = await JWK.toAESGCMKey(key);\n    }\n\n    let prot = JSON.parse(base64DecodeStrJWS(this.protectedB64));\n    if(prot.alg !== \"dir\" || prot.enc !== \"A256GCM\") {\n      throw `unsupported alg + enc - only DIRECT with A256GCM - ${prot.alg} ${prot.enc}`;\n    }\n\n    let dataLen = this.cipherText.byteLength + this.tag.byteLength;\n    let data = new Uint8Array(dataLen);\n    data.set(new Uint8Array(this.cipherText), 0);\n    data.set(new Uint8Array(this.tag), dataLen - 16);\n\n    return arrToStr(await crypto.subtle.decrypt(\n      {name: \"AES-GCM\", iv: this.iv, additionalData: bytesToUint8ArrayBuf(this.protectedB64), tagLength: 128},\n      key,\n      data));\n  }\n}\n","export default class JWT {\n  constructor(iss, sub, id, aud) {\n    this.iss = iss;\n    this.sub = sub;\n    this.id  = id;\n    this.aud = aud;\n\n    // These get set if setExpire(), otherwise they are left out\n    // this.exp = null;\n    // this.nbf = null;\n    // this.iat = null;\n  }\n\n  setExpire(secsAfter, secsBefore) {\n    this.iat = (Date.now() / 1000) | 0;\n    this.exp = this.iat + secsAfter;\n    this.nbf = this.iat - secsBefore;\n    return this;\n  }\n\n  withBody(body) {\n    for(var key in body) {\n      this[key] = body[key];\n    }\n    return this;\n  }\n}\n","export default class IdentityCommsResponse {\n  constructor(raw) {\n    for(var key in raw) {\n      this[key] = raw[key];\n    }\n  }\n\n  isError() {\n    return this.status === undefined || this.status === null ||\n        this.status < 200 || this.status >= 400;\n  }\n};\n","import JWS from './JWS.js';\n\nexport default class IdentityCommsMessage {\n  constructor(type, id, dst, exp, body) {\n    this.type = type;\n    this.id = id;\n    this.dst = dst;\n    this.exp = exp;\n    this.body = body;\n\n    this.srcAddr = \"\";\n    this.srcKeyAddr = \"\";\n    this.kid = \"\";\n  }\n\n  static fromObj(obj) {\n    let out = new IdentityCommsMessage();\n    for(var key in obj) {\n      out[key] = obj[key];\n    }\n    return out;\n  }\n\n  toCompactECDSAP256(srcKID, srcPrivKey) {\n    return JWS.forValuePayload({\n      type: this.type,\n      id:   this.id, \n      dst:  this.dst,\n      exp:  this.exp,\n      body: this.body,\n    }).setKID(srcKID).toCompactECDSAP256(srcPrivKey);\n  }\n}\n","export default class IdentityMetaPublic {\n  constructor(optSrc) {\n    this.identityType = \"\";\n    this.name = \"\";\n    this.clientType = \"Web\";\n    this.version = \"v1.0.0.1\";\n    this.tags = {};\n    this.appAddress = \"\";\n\n    if(optSrc) {\n      for(var key in optSrc) {\n        this[key] = optSrc[key];\n      }\n    }\n  }\n}\n","export default class IdentityMetaPrivate {\n  constructor(optSrc) {\n    this.comms = [];\n    this.tags = {};\n    this.created = 0;\n    this.lastHeardDay = 0;\n\n    if(optSrc) {\n      for(var key in optSrc) {\n        this[key] = optSrc[key];\n      }\n    }\n  }\n}\n","import JWS from './JWS.js';\nimport JWE from './JWE.js';\nimport JWT from './JWT.js';\nimport JWK from './JWK.js';\nimport IdentityCommsResponse from './IdentityCommsResponse.js';\nimport IdentityCommsMessage from './IdentityCommsMessage.js';\nimport IdentityMetaPublic from './IdentityMetaPublic.js';\nimport IdentityMetaPrivate from './IdentityMetaPrivate.js';\n\nimport {jwkThumbSHA256B64, kidToCanonUserHostPath, kidStripHostPath, trimAddr, arrToBytes} from './util.js';\nimport {KIDThumbLength, IdentityMsgType} from './constants.js';\n\nlet debugLogMakeMessage = false;\nexport function logMakeMessage(setTo) {\n  if(setTo !== undefined) {\n    debugLogMakeMessage = setTo;\n  }\n  return debugLogMakeMessage;\n}\n\nlet debugLogExtractMessage = false;\nexport function logExtractMessage(setTo) {\n  if(setTo !== undefined) {\n    debugLogExtractMessage = setTo;\n  }\n  return debugLogExtractMessage;\n}\n\nlet debugLogStringify = true;\nexport function logStringify(setTo) {\n  if(setTo !== undefined) {\n    debugLogStringify = setTo;\n  }\n  return debugLogStringify;\n}\n\n/**\n * IdentityComms wraps the identity registration / management APIs and APIs for\n * messaging across Nix between identities. Using this class requires an API key\n * and secret or a JWT derived from an API key and secret.\n */\nexport default class IdentityComms {\n\n  /**\n   * This only partially initializes communication. If this is a new identity,\n   * it may need to be register()ed. Existing identities can be import()ed or\n   * recover()ed.\n   */\n  constructor({\n    apiKeyID      = null,\n    apiKeySecret  = null,\n    /* or */\n    apiKeyJWTAuth = null,\n\n    nixURL = \"https://api.nix.software\",\n  } = {}) {\n\n\n    this.nixHost = \"\";\n    this.nixURL = nixURL || \"https://api.nix.software\";\n\n    this.apiKeyID = apiKeyID;\n    this.apiKeySecret = apiKeySecret || apiKeyJWTAuth;\n\n    this.address     = null;\n    this.reconnectID = '' + Date.now();\n    this.sigPubKey   = null;\n    this.sigPrivKey  = null;\n    this.encPubKey   = null;\n    this.encPrivKey  = null;\n\n    this.defaultTTLSec = 7 * 24 * 60 * 60; // one week\n    this.nextIDUniq = 0;\n\n    this.metaPublic = new IdentityMetaPublic();\n    this.metaPrivate = new IdentityMetaPrivate();\n\n    this.autoFetch = true;\n\n    this.knownKeys = {};\n    this.keyStore = null;\n  }\n\n  /**\n   * Set the public and private key pairs, addres, and identityType. Fully ready for\n   * communication after this. Note that metadata is fetched.\n   */\n  async import(identityType, address, sigPrivKeyJWK, encPrivKeyJWK, skipFetch) {\n    this.metaPublic.identityType  = identityType;\n\n    this.address = address;\n    this.sigPrivKey = await JWK.toECDSAP256Priv(sigPrivKeyJWK);\n    this.sigPubKey  = await JWK.toECDSAP256Pub(sigPrivKeyJWK);\n    this.encPrivKey = await JWK.toECDHP256Priv(encPrivKeyJWK);\n    this.encPubKey  = await JWK.toECDHP256Pub(encPrivKeyJWK);\n\n    if(skipFetch) {\n      return \n    }\n\n    return await this.fetchMe();\n  }\n\n  /**\n   * internal utility function wrapping HTTP commonalitites.\n   */\n  async reqRaw(method, path, body) {\n    var authHeader = this.apiKeyID ? \n      `Basic ${btoa(this.apiKeyID + \":\" + this.apiKeySecret)}` :\n      `Bearer ${this.apiKeySecret}`;\n\n    return fetch(`${this._nixURL}${path}`, {\n      method: method,\n      cache: 'no-cache',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': authHeader,\n      },\n      redirect: 'follow',\n      body: body ? JSON.stringify(body) : undefined,\n    });\n  }\n\n  async req(method, path, body) {\n    return this.reqRaw(method, path, body).then((resp) => resp.json());\n  }\n\n  /**\n   * Setter strips trailing slashes - URI interpolation assumes paths should add\n   * the slash.\n   */\n  set nixURL(nixURL) {\n    this._nixURL = nixURL.replace(/\\/+$/, \"\");\n    this.nixHost = new URL(this._nixURL).hostname;\n  }\n\n  /**\n   * Register this identity as the optional type (otherwise existing is used).\n   * Current public metadata, private metadata, signing and encryption keys are\n   * used if set, generated if not. On success, the identity is registered and\n   * ready to use. The address will be set and should be saved for restoration.\n   * Consider making an encrypted recovery (buildRecovery() + setRecovery()).\n   */\n  async register(identityType) {\n    let path = '/v1/identity';\n\n    if(identityType) {\n      this.metaPublic.identityType = identityType;\n    }\n\n    if(!this.sigPrivKey) {\n      let sigPair = await crypto.subtle.generateKey(\n        {name: \"ECDSA\", namedCurve: \"P-256\"}, true, [\"sign\"]);\n      this.sigPrivKey = sigPair.privateKey;\n      this.sigPubKey  = sigPair.publicKey;\n    }\n\n    if(!this.encPrivKey) {\n      let encPair = await crypto.subtle.generateKey(\n        {name: \"ECDH\", namedCurve: \"P-256\"}, true, [\"deriveKey\"]);\n      this.encPrivKey = encPair.privateKey;\n      this.encPubKey  = encPair.publicKey;\n    }\n\n    let sigPubKey = await JWK.fromECDSAP256Pub(this.sigPubKey);\n    let sigKID = \"/\" + sigPubKey.kid\n    let encPubKey = await JWK.fromECDHP256Pub(this.encPubKey);\n\n    var request = {\n      sigPubKey: sigPubKey,\n      encPubKey: await JWS.forValuePayload(encPubKey)\n        .setTgtIat(`${path}#encPubKey`).setKID(sigKID)\n        .toCompactECDSAP256(this.sigPrivKey),\n      metaPublic: await JWS.forValuePayload(this.metaPublic)\n        .setTgtIat(`${path}#metaPublic`).setKID(sigKID)\n        .toCompactECDSAP256(this.sigPrivKey),\n      metaPrivate: await JWS.forValuePayload(this.metaPrivate)\n        .setTgtIat(`${path}#metaPrivate`).setKID(sigKID)\n        .toCompactECDSAP256(this.sigPrivKey),\n    }\n\n    let resp = new IdentityCommsResponse(await this.req('POST', path, request));\n\n    if(resp.isError()) {\n      return resp;\n    }\n\n    this.address = resp.body.address;\n    return resp;\n  }\n\n  async curSigKID() {\n    return `${this.address}/${await jwkThumbSHA256B64(await crypto.subtle.exportKey(\"jwk\", this.sigPubKey))}`;\n  }\n\n  /**\n   * Fetch recovery data, descrypt it with password, set the internals of this\n   * identity. Note that metadata is fetched. Identity is fully ready to use on\n   * success. With skipVerify, don't try to validate the signature around the\n   * outside. In most recovery scenarios, skipVerify=true makes sense.\n   */\n  async recover(address, password, skipVerify) {\n    let recovery = await this.fetchRecovery(address, skipVerify);\n    if(recovery.isError()) {\n      throw `couldn't fetch recovery - ${JSON.stringify(recover)}`\n    }\n\n    // if verification was supposed to occur, it already did in fetchRecovery()\n    // and succeeded\n    let objJSON = await JWE.fromCompact(\n      JSON.parse(\n        JWS.fromCompact(recovery.body.jws).UNSAFEExtractPayload()\n      ).jwe)\n      .decryptPBKDF2AES256GCM(password, address);\n\n    let obj = JSON.parse(objJSON);\n    await this.import(obj.type, obj.address, obj.sigPrivKey, obj.encPrivKey);\n    this.autoFetch = obj.autoFetch;\n\n    return await this.fetchMe();\n  }\n\n  /**\n   * Construct a JSON Web Encryption of the keys, address, and type for this\n   * identity. Note that this DOES NOT store anything anywhere. Call\n   * setRecovery() with the returned JWE string.\n   */\n  async buildRecovery(password) {\n    let sigPrivKey = await JWK.fromECDSAP256Priv(this.sigPrivKey);\n    let sigKID = \"/\" + sigPrivKey.kid\n    let encPrivKey = await JWK.fromECDHP256Priv(this.encPrivKey);\n\n    return (await JWE.encryptPBKDF2AES256GCM(\n      password,\n      this.address,\n      JSON.stringify({\n        address: this.address,\n        type: this.metaPublic.identityType,\n        sigPrivKey: sigPrivKey,\n        encPrivKey: encPrivKey,\n        autoFetch: this.autoFetch,\n      }),\n      `${this.address}`\n    )).toCompact();\n  }\n\n  /**\n   * toJSONFull renders a more detailed represenation of the identity with no\n   * encryption and the public and private metadat\n   */\n  async toJSONFull() {\n    let sigPrivKey = await JWK.fromECDSAP256Priv(this.sigPrivKey);\n    let sigKID = \"/\" + sigPrivKey.kid\n    let encPrivKey = await JWK.fromECDHP256Priv(this.encPrivKey);\n\n    return JSON.stringify({\n      nixHost: this.nixHost,\n      nixURL:  this._nixURL,\n      apiKeyID: this.apiKeyID,\n      apiKeySecret: this.apiKeySecret,\n      address: this.address,\n      sigPrivKey: sigPrivKey,\n      encPrivKey: encPrivKey,\n      autoFetch: this.autoFetch,\n      defaultTTLSec: this.defaultTTLSec,\n      metaPublic: this.metaPublic,\n      metaPrivate: this.metaPrivate,\n    });\n  }\n\n  /** \n   * A static constructur from the full JSON\n   */\n  static async fromJSONFull(json) {\n    let full = JSON.parse(json);\n    let comms = new IdentityComms({\n      apiKeyID: full.apiKeyID,\n      apiKeySecret: full.apiKeySecret,\n      nixURL: full.nixURL,\n    });\n\n    await comms.import(full.metaPublic.identityType, full.address, full.sigPrivKey, full.encPrivKey, true);\n    comms.autoFetch = full.autoFetch;\n    comms.defaultTTLSec = full.defaultTTLSec;\n    comms.metaPublic = new IdentityMetaPublic(full.metaPublic);\n    comms.metaPrivate = new IdentityMetaPrivate(full.metaPrivate);\n    return comms;\n  }\n\n  /**\n   * Given the JWE string from buildRecovery() or a JWE built otherwise\n   * containing this identity's private data, sign and store it for later\n   * recovery.  This JWE can be obtained by many other devices to attempt\n   * recovery, so use strong keys and encryption.\n   */\n  async setRecovery(compactJWE) {\n    let path = '/v1/identity/me/data/recovery';\n\n    var request = {\n      jws: await JWS.forValuePayload({\n          name: \"recovery\",\n          jwe: compactJWE,\n        }).setTgtIat(`${path}#jws`).setKID(await this.curSigKID())\n        .toCompactECDSAP256(this.sigPrivKey),\n    }\n\n    return new IdentityCommsResponse(await this.req('POST', path, request));\n  }\n\n  /**\n   * Fetch the recovery JWE for any address. With skipVerify, the signature\n   * around the JWE is not verified. In most recovery scenarios, you will not\n   * have the appropriate knowledge to do verification and skipVerify=true is\n   * reasonable.\n   */\n  async fetchRecovery(address, skipVerify) {\n    let path = `/v1/identity/${address}/data/recovery`;\n    let resp = new IdentityCommsResponse(await this.req('GET', path, null));\n    if (skipVerify) {\n      return resp;\n    }\n\n    let addressJWKs = await this.getKnownKeys(address);\n    let addressSigPubKey = await JWK.toECDSAP256Pub(addressJWKs.sigPubKey);\n\n    // throws if signature fails\n    await JWS.fromCompact(resp.body.jws).verify(addressSigPubKey);\n\n    return resp;\n  }\n\n  /**\n   * Update the signing key and include a new encryption key or resign the\n   * existing encryption key with the new signing key. If the signing key isn't\n   * given, one will be generated. The new signign key will be added to the\n   * signature chain for other idnetities to validate and update. Note that\n   * signatures over old recovery data and other long-term stored signed data\n   * may need to be updated.\n   */\n  async updateSigKey(sigPrivKeyJWK, encPrivKeyJWK) {\n    let path = '/v1/identity/me/sigPubKey';\n\n    let newSigPair = {};\n    if(sigPrivKeyJWK) {\n      newSigPair = {\n        privateKey: await JWK.toECDSAP256Priv(sigPrivKeyJWK),\n        publicKey:  await JWK.toECDSAP256Pub(sigPrivKeyJWK),\n      };\n    } else {\n      newSigPair = await crypto.subtle.generateKey(\n        {name: \"ECDSA\", namedCurve: \"P-256\"}, true, [\"sign\"]);\n    }\n\n    let newEncPair = {publicKey: this.encPubKey, privateKey: this.encPrivKey};\n    if(encPrivKeyJWK) {\n      newEncPair = {\n        privateKey: await JWK.toECDHP256Priv(encPrivKeyJWK),\n        publicKey:  await JWK.toECDSAP256Pub(encPrivKeyJWK),\n      };\n    }\n\n    let sigPubKey = await JWK.fromECDSAP256Pub(newSigPair.publicKey);\n    let encPubKey = await JWK.fromECDHP256Pub(newEncPair.publicKey);\n\n    var request = {\n      sigPubKey: await JWS.forValuePayload(sigPubKey)\n        .setTgtIat(`${path}#sigPubKey`).setKID(await this.curSigKID())\n        .toCompactECDSAP256(this.sigPrivKey),\n      encPubKey: await JWS.forValuePayload(encPubKey)\n        .setTgtIat(`${path}#encPubKey`).setKID(this.address + \"/\" + sigPubKey.kid)\n        .toCompactECDSAP256(newSigPair.privateKey),\n    }\n\n    let resp = new IdentityCommsResponse(await this.req('POST', path, request));\n\n    if(resp.isError()) {\n      return resp;\n    }\n\n    this.sigPrivKey = newSigPair.privateKey;\n    this.sigPubKey  = newSigPair.publicKey;\n    this.encPrivKey = newEncPair.privateKey;\n    this.encPubKey  = newEncPair.publicKey;\n    return resp;\n  }\n\n  /**\n   * Update the encryption key. If one isn't given, a new one will be generated.\n   * Note that you may want to update recovery data.\n   */\n  async updateEncKey(encPrivKeyJWK) {\n    let path = '/v1/identity/me/encPubKey';\n\n    let newEncPair = {};\n    if(encPrivKeyJWK) {\n      newEncPair = {\n        privateKey: await JWK.toECDHP256Priv(encPrivKeyJWK),\n        publicKey:  await JWK.toECDSAP256Pub(encPrivKeyJWK),\n      };\n    } else {\n      newEncPair = await crypto.subtle.generateKey(\n        {name: \"ECDH\", namedCurve: \"P-256\"}, true, [\"deriveKey\"]);\n    }\n\n    let encPubKey = await JWK.fromECDHP256Pub(newEncPair.publicKey);\n    var request = {\n      encPubKey: await JWS.forValuePayload(encPubKey)\n        .setTgtIat(`${path}#encPubKey`).setKID(await this.curSigKID())\n        .toCompactECDSAP256(this.sigPrivKey),\n    }\n\n    let resp = new IdentityCommsResponse(await this.req('POST', path, request));\n\n    if(resp.isError()) {\n      return resp;\n    }\n\n    this.encPrivKey = newEncPair.privateKey;\n    this.encPubKey  = newEncPair.publicKey;\n    return resp;\n  }\n\n  /**\n   * Update the public and/or private metadata for this identity. Given metadata\n   * is used if defined and the internal metadata will be replaced. Otherwise,\n   * the internal metadata is assuemd to be newer than the server and is used.\n   */\n  async updateMeta(metaPublic, metaPrivate) {\n    let path = '/v1/identity/me/meta';\n\n    metaPublic = metaPublic || this.metaPublic;\n    metaPrivate = metaPrivate || this.metaPrivate;\n\n    let curSigKID = await this.curSigKID();\n\n    var request = {\n      metaPublic: await JWS.forValuePayload(metaPublic)\n        .setTgtIat(`${path}#metaPublic`).setKID(curSigKID)\n        .toCompactECDSAP256(this.sigPrivKey),\n      metaPrivate: await JWS.forValuePayload(metaPrivate)\n        .setTgtIat(`${path}#metaPrivate`).setKID(curSigKID)\n        .toCompactECDSAP256(this.sigPrivKey),\n    }\n\n    let resp = new IdentityCommsResponse(await this.req('POST', path, request));\n\n    if(resp.isError()) {\n      return resp;\n    }\n\n    this.metaPublic = metaPublic;\n    this.metaPrivate = metaPrivate;\n    return resp;\n  }\n\n  /**\n   * Get the public keys, signature chain, and metadata about another identity.\n   */\n  async fetchIdentityPublic(address) {\n    return new IdentityCommsResponse(await this.req('GET', `/v1/identity/${address}`, null));\n  }\n\n\n  /**\n   * Get the full identity and private metadata of this identity.\n   */\n  async fetchMe() {\n    let path = '/v1/identity/me';\n\n    var request = {\n      jwt: await JWS.forValuePayload(new JWT(this.address, this.address, this.address, [this.nixHost]).setExpire(300, 300))\n        .setTgtIat(`${path}#jwt`).setKID(await this.curSigKID())\n        .toCompactECDSAP256(this.sigPrivKey),\n    }\n\n    let resp = new IdentityCommsResponse(await this.req('POST', path, request));\n\n    if(resp.isError()) {\n      return resp;\n    }\n\n    this.metaPublic = new IdentityMetaPublic(resp.body.metaPublic);\n    this.metaPrivate = new IdentityMetaPrivate(resp.body.metaPrivate);\n    return resp;\n  }\n\n  /**\n   * Get the current public signing and encryption keys for an identity if\n   * possible. These could come from the local key store, from the cache inside\n   * the IdentityComms, or from the server if autoFetch is enabled (keep in mind\n   * this means trusting Nix).\n   */\n  async getKnownKeys(destAddr, forceFetch) {\n    let [destUserHost, destKeyPfx] = kidToCanonUserHostPath(destAddr);\n\n    if((destUserHost in this.knownKeys) && !(forceFetch === true)) {\n      let destKeys = this.knownKeys[destUserHost];\n      if(!destKeyPfx) {\n        return destKeys;\n      }\n      for(var keyID in destKeys.byID) {\n        if(keyID.startsWith(destKeyPfx)) {\n          var destKey = destKeys.byID[keyID];\n          return destKey.use === 'sig' ? (\n            {sigPubKey: destKey}\n          ): (\n            {encPubKey: destKey}\n          );\n        }\n      }\n    }\n\n    if(this.keyStore && !forceFetch) {\n      try {\n        let result = this.keyStore.getKnownKeys(destAddr);\n        this.addKnownKeys(destAddr, [result.sigPubKey, result.encPubKey]);\n      } catch(e) {\n        // ignore\n      }\n    }\n\n    if(this.autoFetch || forceFetch) {\n      let resp = await this.fetchIdentityPublic(destUserHost);\n      if(!resp.isError()) {\n        let result = {\n          encPubKey: JSON.parse(JWS.fromCompact(resp.body.encPubKey).UNSAFEExtractPayload()),\n          sigPubKey: resp.body.sigPubKey,\n        };\n        this.addKnownKeys(destAddr, [result.sigPubKey, result.encPubKey]);\n\n        if(this.keyStore) {\n          this.keys.setKnownKeys(destAddr, result);\n        }\n        return result;\n      }\n    }\n\n    throw `could not find keys for ${destAddr}`;\n  }\n\n  /**\n   * add zero or more keys to the knownKeys cache - does not pass through to the\n   * keyStore.\n   */\n  async addKnownKeys(addr, keys) {\n    var [userHost] = kidToCanonUserHostPath(addr);\n    keys.map((key) => {\n      if(!key) return;\n      var path = kidStripHostPath(key.kid);\n      if(!this.knownKeys[userHost]) {\n        this.knownKeys[userHost] = {sigPubKey: null, encPubKey: null, byID: {}};\n      }\n      this.knownKeys[userHost].byID[path] = key;\n      if(key.use === \"sig\") {\n        this.knownKeys[userHost].sigPubKey = key;\n      } else if (key.use === \"enc\") {\n        this.knownKeys[userHost].encPubKey = key;\n      }\n    });\n  }\n\n  /**\n   * Validate the message signature, decrypt the message body if needed, and\n   * return the extracted results.\n   */\n  async extractMessage(msg) {\n    let jws = JWS.fromCompact(msg);\n    let srcJWKs = await this.getKnownKeys(jws.kid);\n\n    let srcSigPubKey = await JWK.toECDSAP256Pub(srcJWKs.sigPubKey);\n    let msgBody = JSON.parse(await jws.verify(srcSigPubKey));\n\n    let [srcID] = kidToCanonUserHostPath(jws.kid);\n    let jwe = null;\n    if(msgBody.body.jwe) {\n      jwe = await JWE.fromCompact(msgBody.body.jwe);\n      msgBody.body.jwe = JSON.parse(await jwe.decryptECDHEP256(this.encPrivKey));\n      if (kidToCanonUserHostPath(msgBody.body.jwe.src)[0] !== srcID) {\n        throw \"JWE src doesn't match message signature kid\";\n      }\n    }\n\n    msgBody.src = srcID;\n    msgBody.srcKID = jws.kid;\n\n    if(debugLogExtractMessage) {\n      let logObj = jws.toLogFormat();\n      if(msgBody.body.jwe) {\n        logObj.payload.body.jwe = jwe.toLogFormat(msgBody.body.jwe);\n      }\n      logObj = debugLogStringify ? JSON.stringify(logObj, null, 2) : logObj;\n      console.log(\"extractMessage\\n\", logObj);\n    }\n\n    return msgBody;\n  }\n\n  /**\n   * Generic message construction used by the other message convenience\n   * functions to build, encrypt, sign the needed parts of the message.\n   */\n  async makeMessage(type, destAddr, optValSigned, optValEncrypted) {\n    let now = (Date.now() / 1000) | 0;\n    let uniqID = this.nextIDUniq++;\n    let id = `${now}.${uniqID}`;\n    let srcAddr = trimAddr(this.address);\n\n    destAddr = trimAddr(destAddr);\n\n    let body = optValSigned || {};\n\n    let jwe = null;\n    if(optValEncrypted) {\n      optValEncrypted.src = srcAddr;\n\n      let dstJWKs = await this.getKnownKeys(destAddr);\n      let dstEncPubKey = await JWK.toECDHP256Pub(dstJWKs.encPubKey);\n\n      jwe = await JWE.encryptECDHESP256(\n        dstEncPubKey,\n        JSON.stringify(optValEncrypted),\n        `${destAddr}/${(await jwkThumbSHA256B64(dstJWKs.encPubKey)).slice(0, KIDThumbLength)}`\n      );\n\n      body.jwe = jwe.toCompact();\n    }\n\n    let curSigPubKeyKID = await jwkThumbSHA256B64(await crypto.subtle.exportKey(\"jwk\", this.sigPubKey));\n\n    let out = await (new IdentityCommsMessage(type, id, destAddr, ((Date.now() / 1000) + this.defaultTTLSec) | 0, body))\n      .toCompactECDSAP256(`${srcAddr}/${curSigPubKeyKID.slice(0, KIDThumbLength)}`, this.sigPrivKey);\n\n    if(debugLogMakeMessage) {\n      let logObj = JWS.fromCompact(out).toLogFormat();\n      if(optValEncrypted) {\n        logObj.payload.body.jwe = jwe.toLogFormat(optValEncrypted);\n      }\n      logObj = debugLogStringify ? JSON.stringify(logObj, null, 2) : logObj;\n      console.log(\"makeMessage\\n\", logObj);\n    }\n\n    return out;\n  }\n\n  /**\n   * A clear message indicates that the cache should remove any messages\n   * relevant to content package @kid and that the destination should voluntarily\n   * destroy any currently viewed or cached information relevant to the content\n   * package @kid.\n   */\n  async makeMessageClear(destAddr, kid, optExtraSigned, optExtraEncrypted) {\n    optExtraSigned = optExtraSigned || {};\n    optExtraSigned.kid = kid;\n    return this.makeMessage(IdentityMsgType.Clear, destAddr, optExtraSigned, optExtraEncrypted);\n  }\n\n  /**\n   * Signed messages have no specific meaning to the cache with respect to\n   * content packages. They are simply messages containing data for another\n   * party that can be seen but not modified by the server.\n   */\n  async makeMessageSigned(destAddr, optKID, signed) {\n    if(optKID) {\n      signed = signed || {};\n      signed.kid = optKid;\n    }\n    return this.makeMessage(IdentityMsgType.Signed, destAddr, signed, null);\n  }\n\n  /**\n   * Message encrypted has no meaning to the cache and is simple an end-to-end\n   * encrypted message.\n   */\n  async makeMessageEncrypted(destAddr, optKID, optExtraSigned, encrypted) {\n    if(optKID) {\n      optExtraSigned = optExtraSigned || {};\n      optExtraSigned.kid = optKID;\n    }\n    return this.makeMessage(IdentityMsgType.Encrypted, destAddr, optExtraSigned, encrypted);\n  }\n\n  /**\n   * Message publish is intented to publish a specific content package to the\n   * cache and recipient either for pre-caching or in response to a request.\n   */\n  async makeMessagePublish(destAddr, kid, pkg, optExtraSigned, optExtraEncrypted) {\n    optExtraSigned = optExtraSigned || {};\n    optExtraSigned.kid = kid;\n    optExtraEncrypted = optExtraEncrypted || {};\n    optExtraEncrypted.pkg= pkg;\n    return this.makeMessage(IdentityMsgType.Publish, destAddr, optExtraSigned, optExtraEncrypted);\n  }\n\n  /**\n   * Message request is intended to get a specific content package by @kid from\n   * @destAddr. If the content package has been published to cache, the response\n   * may contain the requested package; otherwise, it can be fetched later.\n   */\n  async makeMessageRequest(destAddr, kid, bypassCache, optExtraSigned, optExtraEncrypted) {\n    optExtraSigned = optExtraSigned || {};\n    optExtraSigned.kid = kid;\n    optExtraSigned.noCache = bypassCache || false;\n    optExtraSigned.encPubKey = await JWK.fromECDHP256Pub(this.encPubKey);\n    return this.makeMessage(IdentityMsgType.Request, destAddr, optExtraSigned, optExtraEncrypted);\n  }\n\n  /**\n   * Send one or more messages to one or more destinations. @messages should be\n   * an array of compact JWS messages built by the utility functions.\n   */\n  async sendMessages(messages) {\n    let resp = new IdentityCommsResponse(await this.req('POST', '/v1/messages/send', {msgs: messages}));\n    if(resp.isError()) {\n      return resp;\n    }\n    resp.body = resp.body? resp.body.map((r) => IdentityCommsMessage.fromObj(r)) : [];\n    return resp;\n  }\n\n  /**\n   * Fetch zero or more messages via polling. Min, max, order, and limit can be\n   * used for pagination with respect to the server timestamps applied to each\n   * message.\n   */\n  async fetchMessages(min, max, order, limit) {\n    let path = '/v1/messages/fetch';\n    let jwt = {};\n\n    if(min) jwt.min = min;\n    if(max) jwt.max = max;\n    if(order) jwt.order = order;\n    if(limit) jwt.limit = limit;\n\n    var request = {\n      jwt: await JWS.forValuePayload(new JWT(this.address, this.address, this.address, [this.nixHost]).setExpire(300, 300).withBody(jwt))\n        .setTgtIat(`${path}#jwt`).setKID(await this.curSigKID())\n        .toCompactECDSAP256(this.sigPrivKey),\n    }\n\n    return new IdentityCommsResponse(await this.req('POST', path, request));\n  }\n\n  /**\n   * streams messages via a POST Long Poll streaming body. for each message\n   * received, onMessage is called with the {ts, msg} body. if redial is true,\n   * errors and disconnects will result in redialing. if given, canceler should\n   * be an object with a member called cancelled that is true when this loop\n   * should end.\n   */\n  async fetchMessageStream(min, max, order, limit, onMessage, redial, canceler, retryTime) {\n    retryTime = retryTime ? 4 : retryTime * 2;\n    if(retryTime > 30000) {\n      retryTime = 30000;\n    }\n\n    let path = '/v1/messages/listen';\n    let jwt = {jti: this.reconnectID};\n\n    if(min) jwt.min = min;\n    if(max) jwt.max = max;\n    if(order) jwt.order = order;\n    if(limit) jwt.limit = limit;\n\n    var request = {\n      jwt: await JWS.forValuePayload(new JWT(this.address, this.address, this.address, [this.nixHost]).setExpire(300, 300).withBody(jwt))\n        .setTgtIat(`${path}#jwt`).setKID(await this.curSigKID())\n        .toCompactECDSAP256(this.sigPrivKey),\n    }\n\n    let maybeRetry = () => {\n      if(redial && (!canceler || !canceler.cancelled)) {\n        setTimeout(this.fetchMessageStream.bind(this, min, max, order, limit, onMessage, redial, canceler), retryTime);\n      }\n    }\n\n    this.reqRaw('POST', path, request).then(resp => {\n      const reader = resp.body.getReader();\n      let curData = '';\n\n      const readFunc = ({end, value}) => {\n        retryTime = 16;\n        if(end) {\n          maybeRetry();\n          return;\n        }\n\n        if(canceler && canceler.canceled) {\n          reader.cancel();\n          return;\n        }\n\n        let curChunk = arrToBytes(value);\n        let newLine = curChunk.indexOf('\\n');\n        while (newLine >= 0) {\n          curData += curChunk.slice(0, newLine);\n          try {\n            onMessage(JSON.parse(curData));\n          } catch(e) {\n            console.error(`identity${this.address}.fetchMessageStream() => onMessage exception`, e);\n          }\n          curData = '';\n          curChunk = curChunk.slice(newLine+1);\n          newLine = curChunk.indexOf('\\n');\n        }\n        curData += curChunk;\n        reader.read().then(readFunc).catch(maybeRetry);\n      };\n\n      reader.read().then(readFunc).catch(maybeRetry);\n    }).catch(maybeRetry);\n  }\n};\n","import JWE from './JWE.js';\nimport {trimAddr} from './util.js';\n\nexport default class ContentPackage {\n  constructor({id = null, routeAddress = null, vaultAddress = null} = {}) {\n    this.route = routeAddress;\n    this.vault = vaultAddress;\n    this.id           = id;\n\n    this.meta = {};\n    this.keys = {};\n    this.perms = {};\n  }\n\n  static async fromObj(obj) {\n    let out = new ContentPackage();\n    for(var key in obj) {\n      out[key] = obj[key];\n    }\n    out.keys = {};\n    for(var key in obj.keys) {\n      out.keys[key] = await crypto.subtle.importKey(\"jwk\", obj.keys[key], {\"name\": \"AES-GCM\"}, true, [\"encrypt\", \"decrypt\"]);\n    }\n    return out;\n  }\n\n  async noPerms() {\n    let out = {\n      route: this.route || undefined,\n      vault: this.vault || undefined,\n      id: this.id,\n\n      meta: this.meta,\n      keys: {},\n    };\n    for(var key in this.keys) {\n      out.keys[key] = await crypto.subtle.exportKey(\"jwk\", this.keys[key]);\n    }\n    return out;\n  }\n\n  async createJWK(optName) {\n    let key = await crypto.subtle.generateKey({name: \"AES-GCM\", length: 256}, true, [\"encrypt\", \"decrypt\"]);\n    if(!optName) {\n      optName = Object.keys(this.keys).length;\n      while(`${optName}` in this.keys) optName++;\n      optName = `${optName}`;\n    }\n    this.keys[optName] = key;\n\n    return this.getJWK(optName);\n  }\n\n  async addJWK(name, jwk, skipJWKMod) {\n    let key = await crypto.subtle.importKey(\"jwk\", jwk, {\"name\": \"AES-GCM\"}, true, [\"encrypt\", \"decrypt\"]);\n    this.keys[name] = key;\n\n    if (skipJWKMod) {\n      return;\n    }\n\n    jwk.use = \"enc\";\n    let route = this.route || this.vault || \"\";\n    jwk.kid = `${trimAddr(route)}/${this.id}/${name}`;\n    if(this.route && this.vault) {\n      jwk.vault = trimAddr(this.vault);\n    }\n    return this;\n  }\n\n  async getJWK(name) {\n    name = name.split(\"/\");\n    name = name[name.length-1];\n\n    if(!(name in this.keys)) {\n      return null;\n    }\n\n    let jwk = await crypto.subtle.exportKey(\"jwk\", this.keys[name]);\n    delete jwk.ext;\n    delete jwk.jwk_ops;\n    jwk.use = \"enc\";\n    let route = this.route || this.vault || \"\";\n    jwk.kid = `${trimAddr(route)}/${this.id}/${name}`;\n    if(this.route && this.vault) {\n      jwk.vault = trimAddr(this.vault);\n    }\n    return jwk;\n  }\n\n  removeJWK(name) {\n    delete this.keys[name];\n  }\n\n  clearJWKs() {\n    this.keys = {};\n  }\n\n  async encrypt(keyName, valueStr, optMediaType, optExtra) {\n    if(!(typeof(valueStr) === \"string\" || valueStr instanceof String)) {\n      throw `value isn't a string - did you forget to encode?`;\n    }\n\n    keyName = keyName.split(\"/\");\n    keyName = keyName[keyName.length-1];\n\n    if(!(keyName in this.keys)) {\n      throw `no key named \"${keyName}\" found`;\n    }\n\n    let route = this.route || this.vault || \"\";\n    let kid = `${trimAddr(route)}/${this.id}/${keyName}`;\n    let protectedObj = optExtra || {};\n    if(this.route && this.vault) {\n      protectedObj.vault = trimAddr(this.vault);\n    }\n    if(optMediaType) {\n      protectedObj.typ = optMediaType;\n    }\n\n    let rslt = (await JWE.encryptDirectAES256GCM(this.keys[keyName], valueStr, kid, protectedObj)).toCompact();\n    return rslt;\n  }\n\n  async decrypt(compactJWE) {\n    let jwe = JWE.fromCompact(compactJWE);\n    let protectedObj = jwe.getProtected();\n    let parts = protectedObj.kid.split(\"/\");\n    let keyName = parts[parts.length-1];\n    let jwk = await this.getJWK(keyName);\n    if(!jwk) {\n      throw `content package ${this.id} does not have a key ${keyName} for this encrypted data`;\n    }\n    return await jwe.decryptDirectAES256GCM(jwk);\n  }\n\n  addMeta(key, value) {\n    if(!(typeof(key) === \"string\" || key instanceof String)) {\n      throw \"metadata keys must be strings\";\n    }\n    if(!(typeof(value) === \"string\" || value instanceof String)) {\n      throw \"metadata values must be strings\";\n    }\n    this.meta[key] = value;\n    return this;\n  }\n\n  getMeta(key) {\n    return this.meta[key];\n  }\n\n  removeMeta(key) {\n    delete this.meta[key];\n  }\n\n  clearMeta(key) {\n    this.meta = {};\n  }\n}\n","import IdentityComms from './IdentityComms.js';\nimport ContentPackage from './ContentPackage.js';\nimport {b64UUID} from './util.js';\nimport {IdentityMsgType} from './constants.js';\nimport {kidToCanonUserHostPath} from './util.js';\n\nexport default class Identity {\n  constructor({comms = null} = {}) {\n    this.comms = comms;\n    this.msgReceiveLoopRunning = false;\n    this.pkgListeners = {};\n    this.clearListeners = {};\n  }\n\n  static async fromJSONFull(json) {\n    let comms = await IdentityComms.fromJSONFull(json);\n    return new Identity({comms: comms});\n  }\n\n  async toJSONFull() {\n    return this.comms.toJSONFull();\n  }\n\n  get address() {\n    return this.comms.address;\n  }\n\n  get name() {\n    return this.comms.metaPublic.name;\n  }\n\n  async setName(name) {\n    return this.comms.metaPublic.name = name;\n  }\n\n  get type() {\n    return this.comms.metaPublic.identityType;\n  }\n\n  async setType(type) {\n    return this.comms.metaPublic.identityType = type;\n  }\n\n  async publishContentPackage(destAddr, pkg) {\n    let pkgNoPerms = await pkg.noPerms();\n    let msg = await this.comms.makeMessagePublish(destAddr, pkg.id, pkgNoPerms, null, {perms: pkg.perms});\n    return await this.comms.sendMessages([msg]);\n  }\n\n  async deleteContentPackage(destAddr, kid) {\n    let msg = await this.comms.makeMessageClear(destAddr, kid);\n    return await this.comms.sendMessages([msg]);\n  }\n\n  async fetchContentPackage(destAddr, kid) {\n    let msg = await this.comms.makeMessageRequest(destAddr, kid);\n    let rslt = await this.comms.sendMessages([msg]);\n    if(rslt.code < 20000 || rslt.code > 29999) {\n      throw(rslt.err);\n    }\n    if(rslt.body[0].code === 20016) {\n      let extractedMsg = await this.comms.extractMessage(rslt.body[0].body[0].msg);\n      return await ContentPackage.fromObj(extractedMsg.body.jwe.pkg);\n    }\n    if(!this.msgReceiveLoopRunning) {\n      setTimeout(this.msgReceiveLoop.bind(this), 5);\n    }\n    return new Promise((resolve, reject) => {\n      [destAddr] = kidToCanonUserHostPath(destAddr);\n      this.pkgListeners[destAddr + \"/\" + kid] = {call: resolve};\n    });\n  }\n\n  async msgReceiveLoop() {\n    this.msgReceiveLoopRunning = true;\n    try {\n      this.comms.fetchMessageStream(null, null, null, null, (msgBody) => {\n        this.comms.extractMessage(msgBody.msg).then((extractedMsg) => {\n          switch(extractedMsg.type) {\n\n            case IdentityMsgType.Publish:\n              if(!extractedMsg.body.jwe || !extractedMsg.body.jwe.pkg) {\n                return;\n              }\n\n              var [src] = kidToCanonUserHostPath(extractedMsg.src);\n              let pkgListenAddr = src + \"/\" + extractedMsg.body.kid;\n              let pkgListeners = this.pkgListeners[pkgListenAddr];\n              if(pkgListeners) {\n                ContentPackage.fromObj(extractedMsg.body.jwe.pkg).then((pkg) => {\n                  pkgListeners.map((l) => {\n                    l.call(pkg, extractedMsg);\n                  });\n                });\n              }\n              delete this.pkgListeners[pkgListenAddr];\n              return;\n\n            case IdentityMsgType.Clear:\n              var [src] = kidToCanonUserHostPath(extractedMsg.src);\n              let clearListenAddr = src + \"/\" + extractedMsg.body.kid;\n              let clearListeners = this.clearListeners[clearListenAddr];\n              if(clearListeners) clearListeners.map((l) => {\n                l.call(extractedMsg.body.kid, extractedMsg);\n              });\n              delete this.clearListeners[clearListenAddr];\n              return;\n          }\n        }).catch((err) => console.error(\"processing err\", err));\n      }, true);\n    } finally {\n      this.msgReceiveLoopRunning = false;\n    }\n  }\n}\n","const instanceOfAny = (object, constructors) => constructors.some(c => object instanceof c);\n\nlet idbProxyableTypes;\r\nlet cursorAdvanceMethods;\r\n// This is a function to prevent it throwing up in node environments.\r\nfunction getIdbProxyableTypes() {\r\n    return idbProxyableTypes ||\r\n        (idbProxyableTypes = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]);\r\n}\r\n// This is a function to prevent it throwing up in node environments.\r\nfunction getCursorAdvanceMethods() {\r\n    return cursorAdvanceMethods || (cursorAdvanceMethods = [\r\n        IDBCursor.prototype.advance,\r\n        IDBCursor.prototype.continue,\r\n        IDBCursor.prototype.continuePrimaryKey,\r\n    ]);\r\n}\r\nconst cursorRequestMap = new WeakMap();\r\nconst transactionDoneMap = new WeakMap();\r\nconst transactionStoreNamesMap = new WeakMap();\r\nconst transformCache = new WeakMap();\r\nconst reverseTransformCache = new WeakMap();\r\nfunction promisifyRequest(request) {\r\n    const promise = new Promise((resolve, reject) => {\r\n        const unlisten = () => {\r\n            request.removeEventListener('success', success);\r\n            request.removeEventListener('error', error);\r\n        };\r\n        const success = () => {\r\n            resolve(wrap(request.result));\r\n            unlisten();\r\n        };\r\n        const error = () => {\r\n            reject(request.error);\r\n            unlisten();\r\n        };\r\n        request.addEventListener('success', success);\r\n        request.addEventListener('error', error);\r\n    });\r\n    promise.then((value) => {\r\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\r\n        // (see wrapFunction).\r\n        if (value instanceof IDBCursor) {\r\n            cursorRequestMap.set(value, request);\r\n        }\r\n        // Catching to avoid \"Uncaught Promise exceptions\"\r\n    }).catch(() => { });\r\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\r\n    // is because we create many promises from a single IDBRequest.\r\n    reverseTransformCache.set(promise, request);\r\n    return promise;\r\n}\r\nfunction cacheDonePromiseForTransaction(tx) {\r\n    // Early bail if we've already created a done promise for this transaction.\r\n    if (transactionDoneMap.has(tx))\r\n        return;\r\n    const done = new Promise((resolve, reject) => {\r\n        const unlisten = () => {\r\n            tx.removeEventListener('complete', complete);\r\n            tx.removeEventListener('error', error);\r\n            tx.removeEventListener('abort', error);\r\n        };\r\n        const complete = () => {\r\n            resolve();\r\n            unlisten();\r\n        };\r\n        const error = () => {\r\n            reject(tx.error);\r\n            unlisten();\r\n        };\r\n        tx.addEventListener('complete', complete);\r\n        tx.addEventListener('error', error);\r\n        tx.addEventListener('abort', error);\r\n    });\r\n    // Cache it for later retrieval.\r\n    transactionDoneMap.set(tx, done);\r\n}\r\nlet idbProxyTraps = {\r\n    get(target, prop, receiver) {\r\n        if (target instanceof IDBTransaction) {\r\n            // Special handling for transaction.done.\r\n            if (prop === 'done')\r\n                return transactionDoneMap.get(target);\r\n            // Polyfill for objectStoreNames because of Edge.\r\n            if (prop === 'objectStoreNames') {\r\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\r\n            }\r\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\r\n            if (prop === 'store') {\r\n                return receiver.objectStoreNames[1] ?\r\n                    undefined : receiver.objectStore(receiver.objectStoreNames[0]);\r\n            }\r\n        }\r\n        // Else transform whatever we get back.\r\n        return wrap(target[prop]);\r\n    },\r\n    has(target, prop) {\r\n        if (target instanceof IDBTransaction && (prop === 'done' || prop === 'store'))\r\n            return true;\r\n        return prop in target;\r\n    },\r\n};\r\nfunction addTraps(callback) {\r\n    idbProxyTraps = callback(idbProxyTraps);\r\n}\r\nfunction wrapFunction(func) {\r\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\r\n    // only create one new func per func.\r\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\r\n    if (func === IDBDatabase.prototype.transaction &&\r\n        !('objectStoreNames' in IDBTransaction.prototype)) {\r\n        return function (storeNames, ...args) {\r\n            const tx = func.call(unwrap(this), storeNames, ...args);\r\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\r\n            return wrap(tx);\r\n        };\r\n    }\r\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\r\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\r\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\r\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\r\n    // undefined if the end of the cursor has been reached.\r\n    if (getCursorAdvanceMethods().includes(func)) {\r\n        return function (...args) {\r\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\r\n            // the original object.\r\n            func.apply(unwrap(this), args);\r\n            return wrap(cursorRequestMap.get(this));\r\n        };\r\n    }\r\n    return function (...args) {\r\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\r\n        // the original object.\r\n        return wrap(func.apply(unwrap(this), args));\r\n    };\r\n}\r\nfunction transformCachableValue(value) {\r\n    if (typeof value === 'function')\r\n        return wrapFunction(value);\r\n    // This doesn't return, it just creates a 'done' promise for the transaction,\r\n    // which is later returned for transaction.done (see idbObjectHandler).\r\n    if (value instanceof IDBTransaction)\r\n        cacheDonePromiseForTransaction(value);\r\n    if (instanceOfAny(value, getIdbProxyableTypes()))\r\n        return new Proxy(value, idbProxyTraps);\r\n    // Return the same value back if we're not going to transform it.\r\n    return value;\r\n}\r\nfunction wrap(value) {\r\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\r\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\r\n    if (value instanceof IDBRequest)\r\n        return promisifyRequest(value);\r\n    // If we've already transformed this value before, reuse the transformed value.\r\n    // This is faster, but it also provides object equality.\r\n    if (transformCache.has(value))\r\n        return transformCache.get(value);\r\n    const newValue = transformCachableValue(value);\r\n    // Not all types are transformed.\r\n    // These may be primitive types, so they can't be WeakMap keys.\r\n    if (newValue !== value) {\r\n        transformCache.set(value, newValue);\r\n        reverseTransformCache.set(newValue, value);\r\n    }\r\n    return newValue;\r\n}\r\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { wrap as a, addTraps as b, instanceOfAny as c, reverseTransformCache as d, unwrap as e };\n","import { a as wrap, b as addTraps } from './chunk.js';\nexport { e as unwrap, a as wrap } from './chunk.js';\n\n/**\r\n * Open a database.\r\n *\r\n * @param name Name of the database.\r\n * @param version Schema version.\r\n * @param callbacks Additional callbacks.\r\n */\r\nfunction openDB(name, version, { blocked, upgrade, blocking } = {}) {\r\n    const request = indexedDB.open(name, version);\r\n    const openPromise = wrap(request);\r\n    if (upgrade) {\r\n        request.addEventListener('upgradeneeded', (event) => {\r\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction));\r\n        });\r\n    }\r\n    if (blocked)\r\n        request.addEventListener('blocked', () => blocked());\r\n    if (blocking)\r\n        openPromise.then(db => db.addEventListener('versionchange', blocking));\r\n    return openPromise;\r\n}\r\n/**\r\n * Delete a database.\r\n *\r\n * @param name Name of the database.\r\n */\r\nfunction deleteDB(name, { blocked } = {}) {\r\n    const request = indexedDB.deleteDatabase(name);\r\n    if (blocked)\r\n        request.addEventListener('blocked', () => blocked());\r\n    return wrap(request).then(() => undefined);\r\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\r\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\r\nconst cachedMethods = new Map();\r\nfunction getMethod(target, prop) {\r\n    if (!(target instanceof IDBDatabase &&\r\n        !(prop in target) &&\r\n        typeof prop === 'string'))\r\n        return;\r\n    if (cachedMethods.get(prop))\r\n        return cachedMethods.get(prop);\r\n    const targetFuncName = prop.replace(/FromIndex$/, '');\r\n    const useIndex = prop !== targetFuncName;\r\n    const isWrite = writeMethods.includes(targetFuncName);\r\n    if (\r\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\r\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\r\n        !(isWrite || readMethods.includes(targetFuncName)))\r\n        return;\r\n    const method = async function (storeName, ...args) {\r\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\r\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\r\n        let target = tx.store;\r\n        if (useIndex)\r\n            target = target.index(args.shift());\r\n        const returnVal = target[targetFuncName](...args);\r\n        if (isWrite)\r\n            await tx.done;\r\n        return returnVal;\r\n    };\r\n    cachedMethods.set(prop, method);\r\n    return method;\r\n}\r\naddTraps(oldTraps => ({\r\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\r\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\r\n}));\n\nexport { openDB, deleteDB };\n","import {openDB} from 'idb';\nimport JWE from './JWE.js';\nimport JWK from './JWK.js';\nimport {IdentityMsgType, VaultOps} from './constants.js';\nimport {kidToCanonUserHostPath} from './util.js';\n\n/**\n * For now in the JS SDK, the Vault and its underlying storage are intermingled\n * in one class. This is mostly because of the way loading, storing, and\n * encryption work.\n */\n\nconst ObjsIdentities = \"identities\";\nconst OIIdxAddr = \"addr\";\n\n// TODO - sign permissions?\nconst ObjsGlobalPerms = \"globalPerms\";\nconst OGPIdxAddr = \"addr\";\nconst OGPIdxPerm = \"perm\";\n\n// TODO - sign permissions?\nconst ObjsContentPkgPerms = \"contentPkgPerms\";\nconst OCPPIdxAddr      = \"addr\";\nconst OCPPIdxPerm         = \"perm\";\nconst OCPPIdxContentPkgID = \"kid\";\n\nconst ObjsContentPkgs = \"contentPkgs\";\nconst OCPIdxContentPkgID  = \"kid\";\n\nconst ObjsConfigs     = \"configs\";\nconst OCIdxKey        = \"key\";\nconst IntermediateKey = \"intermediateKey\";\nconst LatestTS        = \"latestTS\";\n\nconst ObjsKnownMsgIDs = \"knownMsgIDs\";\nconst OKMIIdxID       = \"id\";\n\nexport default class Vault {\n  constructor() {\n    // do nothing because we need async\n  }\n\n  static async forIdentity({\n    identity = null,\n\n    /* optional */\n    dbName = null,\n  } = {}) {\n    let vault = new Vault();\n    vault.identity = identity;\n    // TODO set ourselves as the identity comm's key store\n\n    if(!dbName) {\n      dbName = `nix.${identity.address}`;\n    }\n\n    // need to do this here for upgrade - async inside upgrade can break the txn\n    let intermediateKey = (await JWE.encryptECDHESP256(\n      vault.identity.comms.encPubKey, JSON.stringify(await JWK.randomAESGCM()), IntermediateKey\n    )).toCompact();\n\n    vault.db = await openDB(dbName, 1, {\n      upgrade(db, oldVer, newVer, txn) {\n        if(!oldVer || oldVer < 1) {\n          const identities = db.createObjectStore(ObjsIdentities, {\n            keyPath: OIIdxAddr,\n          });\n\n          const globalPerms = db.createObjectStore(ObjsGlobalPerms, {\n            keyPath: 'id',\n            autoIncrement: true,\n          });\n          globalPerms.createIndex(OGPIdxAddr, OGPIdxAddr);\n          globalPerms.createIndex(OGPIdxPerm, OGPIdxPerm);\n\n          const contentPkgPerms = db.createObjectStore(ObjsContentPkgPerms, {\n            keyPath: 'id',\n            autoIncrement: true,\n          });\n          contentPkgPerms.createIndex(OCPPIdxAddr, OCPPIdxAddr);\n          contentPkgPerms.createIndex(OCPPIdxPerm, OCPPIdxPerm);\n          contentPkgPerms.createIndex(OCPPIdxContentPkgID, OCPPIdxContentPkgID);\n\n          const contentPkgs = db.createObjectStore(ObjsContentPkgs, {\n            keyPath: OCPIdxContentPkgID,\n          });\n\n          const knownMsgIDs = db.createObjectStore(ObjsKnownMsgIDs, {\n            keyPath: OKMIIdxID,\n          });\n\n          const configs = db.createObjectStore(ObjsConfigs, {\n            keyPath: OCIdxKey,\n          });\n\n          configs.add({[OCIdxKey]: IntermediateKey, value: intermediateKey});\n        }\n      },\n    });\n\n    intermediateKey = await vault.db.get(ObjsConfigs, IntermediateKey);\n\n    try {\n      vault.key = await JWK.toAESGCMKey(JSON.parse(await JWE.fromCompact(intermediateKey.value).\n          decryptECDHEP256(vault.identity.comms.encPrivKey)));\n    } catch(e) {\n      throw \"given key / password / jwk could not be used to unlock the store: \"  + e;\n    }\n\n    vault.latestTS = await vault.getConfig(LatestTS);\n    vault.writeLatestTS = null;\n\n    return vault;\n  }\n\n  async setConfig(key, value) {\n      value = (await JWE.encryptDirectAES256GCM(this.key, value)).toCompact();\n      return this.db.put(ObjsConfigs, {[OCIdxKey]: key, value: value});\n  }\n\n  async getConfig(key) {\n      let config = await this.db.get(ObjsConfigs, key);\n      if(!config || !config.value) {\n        return null;\n      }\n      return await JWE.fromCompact(config.value).decryptDirectAES256GCM(this.key);\n  }\n\n  async setAdminIdentity(identity) {\n    // TODO store identity locallty\n    for(var key in VaultOps) {\n      await this.setAllowGlobal(identity.address, VaultOps[key]);\n    }\n  }\n\n  async setAllowGlobal(addr, op) {\n    [addr] = kidToCanonUserHostPath(addr);\n    if(!(await this.isAllowedGlobal(addr, op))) {\n      return this.db.put(ObjsGlobalPerms, {[OGPIdxAddr]: addr, [OGPIdxPerm]: op});\n    }\n  }\n\n  async isAllowedGlobal(addr, op) {\n    [addr] = kidToCanonUserHostPath(addr);\n    const index  = this.db.transaction(ObjsGlobalPerms).store.index(OGPIdxAddr);\n    let cursor = await index.openCursor(addr);\n    while(cursor) {\n      if (cursor.value[OGPIdxPerm] === op) {\n        return true;\n      }\n      cursor = await cursor.continue();\n    }\n    return false;\n  }\n\n  async setAllowContentPackage(addr, op, kid) {\n    [addr] = kidToCanonUserHostPath(addr);\n    if(!(await this.isAllowedContentPackage(addr, op, kid, true))) {\n      return this.db.put(ObjsContentPkgPerms, {[OCPPIdxAddr]: addr, [OCPPIdxPerm]: op, [OCPPIdxContentPkgID]: kid});\n    }\n  }\n\n  async isAllowedContentPackage(addr, op, kid, noGlobal) {\n    if ((!noGlobal) && (await this.isAllowedGlobal(addr, op))) {\n      return true;\n    }\n\n    [addr] = kidToCanonUserHostPath(addr);\n    const index  = this.db.transaction(ObjsContentPkgPerms).store.index(OCPPIdxContentPkgID);\n    let cursor = await index.openCursor(kid);\n    while(cursor) {\n      if (cursor.value[OCPPIdxPerm] === op && cursor.value[OCPPIdxAddr] === addr) {\n        return true;\n      }\n      cursor = await cursor.continue();\n    }\n    return false;\n  }\n\n  async gatherContentPackagePerms(kid) {\n    const index  = this.db.transaction(ObjsContentPkgPerms).store.index(OCPPIdxContentPkgID);\n    let cursor = await index.openCursor(kid);\n    let perms = {};\n    while(cursor) {\n      let perm = cursor.value[OCPPIdxPerm];\n      let addr = cursor.value[OCPPIdxAddr];\n      if(!perms[perm]) {\n        perms[perm] = [];\n      }\n      perms[perm].push(addr);\n      cursor = await cursor.continue();\n    }\n    return perms;\n  }\n\n  async processedBefore(ts, msgID) {\n    let cut = ts.length - 9;\n    let secs = ts.slice(0, cut);\n    this.latestTS = (Number(secs) - (2 * 60) | 0) + ts.slice(cut);\n\n    let obj = await this.db.get(ObjsKnownMsgIDs, ts + msgID);\n    if(obj && obj[OKMIIdxID]) {\n      return true;\n    }\n\n    await this.db.put(ObjsKnownMsgIDs, {[OKMIIdxID]: ts + msgID});\n\n    if(!this.writeLatestTS) {\n      this.writeLatestTS = setTimeout(() => {\n        this.setConfig(LatestTS, this.latestTS).then(() => {});\n        this.writeLatestTS = null;\n      }, 1000);\n    }\n    return false;\n  }\n\n  async fetchLoop() {\n    // Step 1 - catchup\n    const limit = 10;\n    let msgs = [];\n    do {\n      msgs = await this.identity.comms.fetchMessages(this.latestTS, null, \"DESC\", limit);\n      for(let i = 0; i < msgs.length; i++) {\n        await this.messageReceived(msgs[i]);\n      }\n    } while(msgs.length >= limit);\n    // Step 2 - enter streaming\n    this.identity.comms.fetchMessageStream(this.latestTS, null, null, null, (msg) => {\n      try {\n        this.messageReceived(msg).then(()=>{});\n      } catch(err) {\n        console.log(\"Vault: error processing msg:\", msg, \"err:\", err);\n      }\n    });\n  }\n\n  async messageReceived(msgBody) {\n    // the comms class extracting the message validates the that identity is\n    // known and the message is authentic. further processing will decide\n    // whether the operation is allowed.\n    let extractedMsg = await this.identity.comms.extractMessage(msgBody.msg);\n\n    if(await this.processedBefore(msgBody.ts, extractedMsg.id)) {\n      return;\n    }\n\n    switch(extractedMsg.type) {\n      case IdentityMsgType.Encrypted:\n        return this.encryptedMessageReceived(extractedMsg);\n      case IdentityMsgType.Signed:\n        return this.signedMessageReceived(extractedMsg);\n      case IdentityMsgType.Publish:\n        return this.contentPackagePublishReceived(extractedMsg);\n      case IdentityMsgType.Clear:\n        return this.contentPackageClearReceived(extractedMsg);\n      case IdentityMsgType.Request:\n        return this.contentPackageRequestReceived(extractedMsg);\n    }\n    throw `Unhandled message type ${extractedMsg.type}`;\n  }\n\n  async signedMessageReceived(msg) {\n    console.warn(\"not implemented :-D\");\n  }\n\n  async encryptedMessageReceived(msg) {\n    console.warn(\"not implemented :-D\");\n  }\n\n  async contentPackagePublishReceived(msg) {\n    if(!(await this.isAllowedContentPackage(msg.src, VaultOps.ContentPkgRead, msg.body.kid))) {\n        return this.respondNotAllowedContentPackage(msg.id, msg.src,  VaultOps.ContentPkgRead, msg.body.kid);\n    }\n\n    if (msg.body.jwe.pkg) {\n      if(!(await this.isAllowedContentPackage(msg.src, VaultOps.ContentPkgWrite, msg.body.kid))) {\n        return this.respondNotAllowedContentPackage(msg.id, msg.src,  VaultOps.ContentPkgWrite, msg.body.kid);\n      }\n    }\n    // may be allowed to write content packages (or this one in particular), but\n    // not to modify permissions\n    if (msg.body.jwe.perms && Object.keys(msg.body.jwe.perms).length > 0) {\n      if(!(await this.isAllowedContentPackage(msg.src, VaultOps.ContentPkgControl, msg.body.kid))) {\n        return this.respondNotAllowedContentPackage(msg.id, msg.src,  VaultOps.ContentPkgControl, msg.body.kid);\n      }\n    } else if (await this.isAllowedContentPackage(msg.src, VaultOps.ContentPkgControl, msg.body.kid)) {\n      msg.body.jwe.perms = await this.gatherContentPackagePerms(msg.body.kid);\n    }\n\n    if (msg.body.jwe.pkg) {\n      await this.setContentPackage(msg.body.kid, msg.body.jwe.pkg);\n    }\n\n    if (msg.body.jwe.perms) {\n      await this.updateContentPackagePerms(msg.body.kid, msg.body.jwe.perms, msg.body.jwe.pkg);\n    }\n\n    return this.respondContentPackagePublish(msg.id, msg.src, msg.body.kid, msg.body.jwe.pkg, msg.body.jwe.perms);\n  }\n\n  async contentPackageClearReceived(msg) {\n    if(!(await this.isAllowedContentPackage(msg.src, VaultOps.ContentPkgWrite, msg.body.kid))) {\n      return this.respondNotAllowedContentPackage(msg.id, msg.src,  VaultOps.ContentPkgWrite, msg.body.kid);\n    }\n\n    await this.deleteContentPackage(msg.body.kid);\n\n      await this.clearContentPackageReaders(msg.body.kid);\n\n    // may be allowed to write content packages (or this one in particular), but\n    // not to modify permissions. if allowed, delete all permissions\n    if(await this.isAllowedContentPackage(msg.src, VaultOps.ContentPkgControl, msg.body.kid)) {\n      await this.deleteContentPackagePerms(msg.body.kid);\n    }\n\n    return this.respondContentPackageClear(msg.id, msg.src, msg.body.kid);\n  }\n\n  async contentPackageRequestReceived(msg) {\n    if(!(await this.isAllowedContentPackage(msg.src, VaultOps.ContentPkgRead, msg.body.kid))) {\n      return this.respondNotAllowedContentPackage(msg.id, msg.src,  VaultOps.ContentPkgRead, msg.body.kid);\n    }\n\n    let pkg = await this.getContentPackage(msg.body.kid);\n    return this.respondContentPackagePublish(msg.id, msg.src, msg.body.kid, pkg);\n  }\n\n  async respondNotAllowedGeneral(msgID, addr, op) {\n    let msg = await this.identity.comms.makeMessageEncrypted(addr, undefined, {respTo: msgID}, {status: 401});\n    await this.identity.comms.sendmEssages([msg]);\n  }\n\n  async respondNotAllowedContentPackage(msgID, addr, op, kid) {\n    let msg = await this.identity.comms.makeMessageEncrypted(addr, kid, {respTo: msgID}, {status: 401});\n    await this.identity.comms.sendMessages([msg]);\n  }\n\n  async respondContentPackagePublish(msgID, addr, kid, pkg, perms) {\n    let extra = {respTo: msgID}\n    if(perms) {\n      extra.perms = perms;\n    }\n    let msg = await this.identity.comms.makeMessagePublish(addr, kid, pkg, extra);\n    await this.identity.comms.sendMessages([msg]);\n  }\n\n  async respondContentPackageClear(msgID, addr, kid) {\n    let msg = await this.identity.comms.makeMessageClear(addr, kid, {respTo: msgID});\n    await this.identity.comms.sendMessages([msg]);\n  }\n\n  async setContentPackage(kid, pkg) {\n    let value = (await JWE.encryptDirectAES256GCM(this.key, pkg)).toCompact();\n    return this.db.put(ObjsContentPkgs, {[OCPIdxContentPkgID]: kid, value: value});\n  }\n\n  async getContentPackage(kid) {\n    let row = await this.db.get(ObjsContentPkgs, kid);\n    if(!row || !row.value) {\n      return null;\n    }\n    return await JWE.fromCompact(row.value).decryptDirectAES256GCM(this.key);\n  }\n\n  async deleteContentPackage(kid, pkg) {\n    return this.db.delete(ObjsContentPkgs, kid);\n  }\n\n  async updateContentPackagePerms(kid, perms, optPkg) {\n    if(!optPkg) {\n      optPkg = await this.getContentPackage(kid);\n    }\n\n    // TODO - redo, diff existing, use batches, etc.\n    let readers = perms[VaultOps.ContentPkgRead];\n    for(var i in readers) {\n      await this.setAllowContentPackage(readers[i], VaultOps.ContentPkgRead, kid);\n      await this.respondContentPackagePublish(undefined, readers[i], kid, optPkg);\n    }\n    // TODO complete diff new status against existing, generate clear messages,\n    // publish messages, etc.\n    console.warn(\"not implemented :-D\");\n  }\n\n  async clearContentPackageReaders(kid, ignoreAddr) {\n    var addresses = {};\n\n    let index  = this.db.transaction(ObjsGlobalPerms).store.index(OGPIdxPerm);\n    let cursor = await index.openCursor(VaultOps.ContentPkgRead);\n    while(cursor) {\n      addresses[cursor.value[OGPIdxAddr]] = true;\n      cursor = await cursor.continue();\n    }\n\n    index  = this.db.transaction(ObjsContentPkgPerms).store.index(OCPPIdxContentPkgID);\n    cursor = await index.openCursor(kid);\n    while(cursor) {\n      if(cursor.value[OCPPIdxPerm] === VaultOps.ContentPkgRead) {\n        addresses[cursor.value[OCPPIdxAddr]] = true;\n      }\n      cursor = await cursor.continue();\n    }\n\n    var msgs = [];\n    addresses = Object.keys(addresses);\n    for(var i in addresses) {\n      if(addresses[i] === ignoreAddr) {\n        continue;\n      }\n\n      msgs.push(await this.identity.comms.makeMessageClear(addresses[i], kid));\n      if(msgs.length >= 8) {\n        await this.identity.comms.sendMessages(msgs.slice(0, 8));\n        msgs = msgs.slice(8);\n      }\n    }\n\n    await this.identity.comms.sendMessages(msgs);\n  }\n\n  async deleteContentPackagePerms(kid, pkg) {\n    const index  = this.db.transaction(ObjsContentPkgPerms, 'readwrite').store.index(OCPPIdxContentPkgID);\n    let cursor = await index.openCursor(kid);\n    while(cursor) {\n      await cursor.delete();\n      cursor = await cursor.continue();\n    }\n  }\n}\n","import Vault from './Vault.js';\n\nexport default class VaultManager {\n  constructor() {\n    this.vaults = {};\n  }\n\n  async bootVaults(vaultIdentities, admins) {\n    for(let i = 0; i < vaultIdentities.length; i++) {\n      let vault = await Vault.forIdentity({identity: vaultIdentities[i]});\n      for(var j in admins) {\n        if(!admins[j]) {\n          continue;\n        }\n        await vault.setAdminIdentity(admins[j]);\n      }\n      await vault.fetchLoop();\n      this.vaults[vaultIdentities[i].address] = vault;\n    }\n  }\n}\n","import * as constants from './constants.js';\nimport {b64UUID} from './util.js';\nimport IdentityComms from './IdentityComms.js';\nimport Identity from './Identity.js';\nimport ContentPackage from './ContentPackage.js';\nimport VaultManager from './VaultManager.js';\nimport JWE from './JWE.js';\n\nexport default class Client {\n  constructor({\n    defaultAPIKeyID     = null,\n    defaultAPIKeySecret = null,\n    /* or */\n    defaultAPIKeyJWT    = null,\n\n    defaultNixURL = \"https://api.nix.software\",\n\n    store = null,\n  } = {}) {\n    this.defaultAPIKeyID     = defaultAPIKeyID;\n    this.defaultAPIKeySecret = defaultAPIKeySecret;\n    this.defaultAPIKeyJWT    = defaultAPIKeyJWT;\n    this.defaultNixURL       = defaultNixURL;\n    this.store = store;\n    if(!this.store) {\n      throw \"store must be given - there is no default\";\n    }\n\n    if(this.store.setDefaults) {\n      this.store.setDefaults({\n        defaultAPIKeyID:     this.defaultAPIKeyID,\n        defaultAPIKeySecret: this.defaultAPIKeySecret,\n        defaultAPIKeyJWT:    this.defaultAPIKeyJWT,\n        defaultNixURL:       this.defaultNixURL,\n      })\n    }\n    this.vaultManager = new VaultManager();\n  }\n\n  async init() {\n    this.defaultAPIKeyID     = this.defaultAPIKeyID || await this.store.loadConfig(\"defaultAPIKeyID\");\n    this.defaultAPIKeySecret = this.defaultAPIKeySecret || await this.store.loadConfig(\"defaultAPIKeySecret\");\n    this.defaultAPIKeyJWT    = this.defaultAPIKeyJWT || await this.store.loadConfig(\"defaultAPIKeyJWT\");\n    if(!this.defaultAPIKeyJWT && !(this.defaultAPIKeyID && this.defaultAPIKeySecret)) {\n      throw \"an API key ID and secret or JWT is required\";\n    }\n\n    this.defaultNixURL = this.defaultNixURL || await this.store.loadConfig(\"defaultAPIKeyID\");\n    if(!this.defaultNixURL) {\n      throw \"a defaultNixURL is required\";\n    }\n\n    this.defaultIdentities = {\n      [constants.IdentityTypeUnknown] : null,\n      [constants.IdentityTypeApp]     : null,\n      [constants.IdentityTypeGroup]   : null,\n      [constants.IdentityTypeRoute]   : null,\n      [constants.IdentityTypeUser]    : null,\n      [constants.IdentityTypeVault]   : null,\n    }\n\n    for(var type in this.defaultIdentities) {\n      let address = await this.store.loadConfig(`defaultIdentities.${type}`)\n      if(!address) {\n        continue;\n      }\n      let identity = await this.store.getIdentityByAddress(address);\n      this.defaultIdentities[type] = identity;\n    }\n\n    let vaults = await this.store.getIdentitiesByType(constants.IdentityTypeVault);\n    await this.vaultManager.bootVaults(vaults, [\n      this.defaultIdentities[constants.IdentityTypeApp],\n      this.defaultIdentities[constants.IdentityTypeUser],\n    ]);\n\n    return this;\n  }\n\n  async newIdentity({\n    type = constants.IdentityTypeUnknown,\n    name = \"\",\n    apiKeyID = \"\",\n    apiKeySecret = \"\",\n    apiKeyJWT = \"\",\n    nixURL = \"\"} = {}) {\n\n    let comms = new IdentityComms({\n      apiKeyID:     apiKeyID     || this.defaultAPIKeyID, \n      apiKeySecret: apiKeySecret || this.defaultAPIKeySecret, \n      apiKeyJWT:    apiKeyJWT    || this.defaultAPIKeyJWT, \n      nixURL:       nixURL       || this.defaultNixURL, \n    });\n\n    comms.metaPublic.name = name;\n    comms.metaPublic.identityType = type;\n\n    await comms.register(type);\n    let identity = new Identity({comms: comms});\n    await this.store.storeIdentity(identity)\n    if(type === constants.IdentityTypeVault) {\n      this.vaultManager.bootVaults([identity], [\n        this.defaultIdentities[constants.IdentityTypeApp],\n        this.defaultIdentities[constants.IdentityTypeUser],\n      ]);\n    }\n    return identity;\n  }\n\n  async newContentPackage(id) {\n    if(!id) {\n      id = await b64UUID();\n    }\n    return new ContentPackage({\n      id: id,\n      routeAddress: this.getDefaultIdentityAddress(constants.IdentityTypeRoute),\n      vaultAddress: this.getDefaultIdentityAddress(constants.IdentityTypeVault),\n    });\n  }\n\n  async encrypt(text) {\n    let contentPkg = await this.newContentPackage();\n    let jwk = await contentPkg.createJWK();\n    let cipherText = await contentPkg.encrypt(jwk.kid, text);\n    let appIdentity = this.getDefaultIdentity(constants.IdentityTypeApp);\n    let vaultIdentity = this.getDefaultIdentity(constants.IdentityTypeVault);\n    await appIdentity.publishContentPackage(vaultIdentity.address, contentPkg);\n    return cipherText;\n  }\n\n  async decrypt(compactJWE) {\n    let jwe = JWE.fromCompact(compactJWE);\n    let protectedObj = jwe.getProtected();\n    let kidParts = protectedObj.kid.split(\"/\");\n    let address = kidParts[0];\n    let kid = kidParts[1];\n    let appIdentity = this.getDefaultIdentity(constants.IdentityTypeApp);\n    let pkg = await appIdentity.fetchContentPackage(address, kid);\n    return await pkg.decrypt(compactJWE);\n  }\n\n  async decryptAll(text) {\n    let parts = text.split(constants.JWERegex);\n    let promises = [];\n    for(var i = 1; i < parts.length; i += 2) {\n      promises.push(this.decrypt(parts[i]));\n    }\n    let decrypted = await Promise.all(promises);\n    for(var i = 1; i < parts.length; i += 2) {\n      parts[i] = decrypted[(i-1)/2];\n    }\n    return parts.join('');\n  }\n\n  async addIdentity(identity) {\n    await this.store.storeIdentity(identity)\n  }\n\n  async getIdentityByName(name) {\n    return this.store.getIdentityByName(name)\n  }\n\n  async getOrCreateIdentityByName(name, type, dontSetDefault) {\n    let identity = await this.getIdentityByName(name);\n    if(!identity) {\n      identity = await this.newIdentity({name: name, type: type});\n      if(!dontSetDefault) {\n        await this.setDefaultIdentity(identity);\n      }\n    }\n    return identity;\n  }\n\n  async getIdentityByAddress(address) {\n    return this.store.getIdentityByAddress(address)\n  }\n\n  async setDefaultIdentity(identity) {\n    await this.store.storeIdentity(identity)\n    await this.store.storeConfig(`defaultIdentities.${identity.type}`, identity.address);\n    this.defaultIdentities[identity.type] = identity;\n  }\n\n  getDefaultIdentity(type) {\n    return this.defaultIdentities[type];\n  }\n\n  getDefaultIdentityAddress(type) {\n    let identity = this.getDefaultIdentity(type);\n    return identity ? identity.address : null;\n  }\n}\n","import JWE from './JWE.js';\nimport JWK from './JWK.js';\nimport {openDB} from 'idb';\nimport Identity from './Identity.js';\n\n// DB constants\nconst ObjsIdentities = \"identities\";\n\nconst KeyAddress = \"address\";\nconst IdxName = \"name\";\nconst IdxType = \"type\";\n\nconst ObjsConfigs = \"configs\";\nconst Key = \"key\";\n\nconst IntermediateKey      = \"intermediateKey\";\n\nexport default class LocalEncryptedStore {\n  /**\n   * SHOULD NOT BE USED DIRECTLY - call fromPasswordKeyOrJWK()\n   */\n  constructor() {}\n\n  static async fromPasswordKeyOrJWK({\n    /* one of these three must be given */\n    password = null,\n    key      = null,\n    jwk      = null,\n\n    optName = \"nix.localEncryptedStore\",\n  } = {}) {\n    let lep  = new LocalEncryptedStore();\n\n    lep.dbName = optName;\n    lep.key = key;\n    if(password) {\n      lep.key = await JWE.pbkdf2(password, \"jweStore\");\n    }\n    if(jwk) {\n      lep.key = await JWK.toAESGCMKey(lep.jwk);\n    }\n\n    // note that the \"key\" is only used to decrypt the intermediate key in the\n    // datastore to allow changing this outer key without re-encrypting the\n    // entire DB\n    if(!lep.key) {\n      throw \"key, password, or JWK is required\";\n    }\n    if(lep.key.algorithm.name !== \"AES-GCM\" || lep.key.algorithm.length !== 256) {\n      throw `unsupported key - only AES-GCM 256 - ${JSON.stringify(lep.key.algorithm)}`;\n    }\n\n    return lep.startDB();\n  }\n\n  async startDB() {\n    this.dbName = this.dbName || \"nix.localEncryptedStore\";\n\n    // need to do this here for upgrade - async inside upgrade can break the txn\n    let intermediateKey = (await JWE.encryptDirectAES256GCM(this.key, JSON.stringify(await JWK.randomAESGCM()), IntermediateKey)).toCompact();\n\n    this.db = await openDB(this.dbName, 1, {\n      upgrade(db, oldVer, newVer, txn) {\n        if(!oldVer || oldVer < 1) {\n          const identities = db.createObjectStore(ObjsIdentities, {\n            keyPath: KeyAddress,\n          });\n          identities.createIndex(IdxName, IdxName);\n          identities.createIndex(IdxType, IdxType);\n\n          const configs = db.createObjectStore(ObjsConfigs, {\n            keyPath: Key,\n          });\n          configs.add({key: IntermediateKey, value: intermediateKey});\n        }\n      },\n    });\n\n    intermediateKey = await this.db.get(ObjsConfigs, IntermediateKey);\n\n    try {\n      this.key = await JWK.toAESGCMKey(JSON.parse(await JWE.fromCompact(intermediateKey.value).decryptDirectAES256GCM(this.key)));\n    } catch(e) {\n      throw \"given key / password / jwk could not be used to unlock the store: \"  + e;\n    }\n\n    return this;\n  }\n\n  async storeIdentity(identity) {\n    let fullJSON =  await identity.toJSONFull();\n    return this.db.put(ObjsIdentities, {\n      [KeyAddress]: identity.address,\n      [IdxName]:    identity.name,\n      [IdxType]:    identity.type,\n      JWE:   (await JWE.encryptDirectAES256GCM(\n        this.key, fullJSON, identity.address)).toCompact(),\n    })\n  }\n\n  async getIdentitiesByType(type) {\n    let objs = await this.db.getAllFromIndex(ObjsIdentities, IdxType, type);\n    if(!objs) {\n      return null;\n    }\n    let out = [];\n    for(let i = 0; i < objs.length; i++) {\n      let fullJSON = await JWE.fromCompact(objs[i].JWE).decryptDirectAES256GCM(this.key);\n      out.push(await Identity.fromJSONFull(fullJSON));\n    }\n    return out;\n  }\n\n  async getIdentityByName(name) {\n    let obj = await this.db.getFromIndex(ObjsIdentities, IdxName, name);\n    if(!obj || !obj.JWE) {\n      return null;\n    }\n    let fullJSON = await JWE.fromCompact(obj.JWE).decryptDirectAES256GCM(this.key);\n    return Identity.fromJSONFull(fullJSON);\n  }\n\n  async getIdentityByAddress(address) {\n    let obj = await this.db.get(ObjsIdentities, address);\n    if(!obj || !obj.JWE) {\n      return null;\n    }\n    let fullJSON = await JWE.fromCompact(obj.JWE).decryptDirectAES256GCM(this.key);\n    return Identity.fromJSONFull(fullJSON);\n  }\n\n  async storeConfig(key, val) {\n    return this.db.put(ObjsConfigs, {\n      [Key]: key,\n      JWE:   (await JWE.encryptDirectAES256GCM(\n        this.key, JSON.stringify(val), key)).toCompact(),\n    })\n  }\n\n  async loadConfig(key) {\n    let obj = await this.db.get(ObjsConfigs, key);\n    if(!obj || !obj.JWE) {\n      return null;\n    }\n    let json = await JWE.fromCompact(obj.JWE).decryptDirectAES256GCM(this.key);\n    return JSON.parse(json);\n  }\n}\n","import JWE from './JWE.js';\nimport LocalEncryptedStore from './LocalEncryptedStore.js';\nimport IdentityComms from './IdentityComms.js';\nimport Identity from './Identity.js';\n\nexport default class RecoveryAndLocalEncryptedStore extends LocalEncryptedStore {\n  /**\n   * SHOULD NOT BE USED DIRECTLY - call fromPasswordKeyOrJWK()\n   */\n  constructor() {\n    super();\n  }\n\n  static async fromPassword(password) {\n    let lep  = new RecoveryAndLocalEncryptedStore();\n\n    if(!password) {\n      throw \"password is required\";\n    }\n\n    lep.password = password;\n    lep.key = await JWE.pbkdf2(password, \"jweStore\");\n\n    return lep.startDB();\n  }\n\n  setDefaults({\n    defaultAPIKeyID     = null,\n    defaultAPIKeySecret = null,\n    defaultAPIKeyJWT    = null,\n    defaultNixURL       = null,\n  } = {}) {\n    this.defaultAPIKeyID     = defaultAPIKeyID;\n    this.defaultAPIKeySecret = defaultAPIKeySecret;\n    this.defaultAPIKeyJWT    = defaultAPIKeyJWT;\n    this.defaultNixURL       = defaultNixURL;\n    this.defaultsSet         = true;\n  }\n\n  async storeIdentity(identity) {\n    await identity.comms.setRecovery(await identity.comms.buildRecovery(this.password));\n    return LocalEncryptedStore.prototype.storeIdentity.call(this, identity);\n  }\n\n  async getIdentityByAddress(address) {\n    let identity = await LocalEncryptedStore.prototype.getIdentityByAddress.call(this, address);\n    if(identity) {\n      return identity;\n    }\n    if(!this.defaultsSet) {\n      return null;\n    }\n\n    try {\n      let comms = new IdentityComms({\n        apiKeyID:     this.defaultAPIKeyID, \n        apiKeySecret: this.defaultAPIKeySecret, \n        apiKeyJWT:    this.defaultAPIKeyJWT, \n        nixURL:       this.defaultNixURL, \n      });\n\n      await comms.recover(address, this.password, true);\n      return new Identity({comms: comms});\n    } catch(e) {\n      return null;\n    }\n\n    return null;\n  }\n}\n\n","import Client from './Client.js';\n\nimport ContentPackage from './ContentPackage.js';\n\nimport Identity              from './Identity.js';\nimport IdentityComms         from './IdentityComms.js';\nimport {logMakeMessage, logExtractMessage} from './IdentityComms.js';\nimport IdentityCommsMessage  from './IdentityCommsMessage.js';\nimport IdentityCommsResponse from './IdentityCommsResponse.js';\n\nimport IdentityMetaPublic  from './IdentityMetaPublic.js';\nimport IdentityMetaPrivate from './IdentityMetaPrivate.js';\n\nimport JWE from './JWE.js';\nimport JWS from './JWS.js';\nimport JWK from './JWK.js';\nimport JWT from './JWT.js';\n\nimport LocalEncryptedStore from './LocalEncryptedStore.js';\nimport RecoveryAndLocalEncryptedStore from './RecoveryAndLocalEncryptedStore.js';\n\nimport * as constants from './constants.js';\nimport * as util from './util.js';\n\n\nlet jose = {\n    JWE,\n    JWS,\n    JWK,\n    JWT,\n};\n\nlet stores = {\n  LocalEncryptedStore,\n  RecoveryAndLocalEncryptedStore,\n};\n\nlet debug = {\n  logMakeMessage,\n  logExtractMessage,\n};\n\nexport {\n  Client,\n\n  ContentPackage,\n\n  Identity,\n  IdentityComms,\n  IdentityCommsMessage,\n  IdentityCommsResponse,\n\n  IdentityMetaPrivate,\n  IdentityMetaPublic,\n\n  jose,\n  stores,\n\n  constants,\n  util,\n  debug,\n};\n"],"names":["_Pact","prototype","then","onFulfilled","onRejected","result","state","this","s","callback","_settle","v","e","o","_this","value","pact","bind","observer","_isSettledPact","thenable","_forTo","array","body","check","reject","i","_cycle","length","_forIn","target","keys","key","push","_for","test","update","stage","shouldContinue","updateValue","_resumeAfterTest","_resumeAfterBody","_resumeAfterUpdate","_catch","recover","Symbol","iterator","asyncIterator","const","IdentityTypeUnknown","IdentityTypeApp","IdentityTypeGroup","IdentityTypeRoute","IdentityTypeUser","IdentityTypeVault","KIDThumbLength","IdentityMsgType","Signed","Encrypted","Request","Publish","Clear","VaultOps","ContentPkgRead","ContentPkgWrite","ContentPkgControl","IdentitiesRead","IdentitiesWrite","IdentitiesControl","VaultRead","VaultWrite","VaultControl","JWERegex","b64UUID","Uint8Array","crypto","getRandomValues","base64EncodeBytesJWS","arrToBytes","base64EncodeStr","str","btoa","encodeURIComponent","replace","match","p1","String","fromCharCode","base64EncodeStrJWS","base64EncodeBytes","base64EncodeBytesURL","base64DecodeStr","decodeURIComponent","atob","split","map","c","charCodeAt","toString","slice","join","base64DecodeStrJWS","base64DecodeBytes","base64DecodeBytesJWS","strToUtf8ArrayBuf","bytesToUint8ArrayBuf","bytesToUint8Array","buffer","arr","bytesToLenPrefixUint8Array","errPromise","val","Promise","resolve","successPromise","jwkThumbSHA256B64","jwk","kty","crv","subtle","digest","name","hash","out","u8arr","len","byteLength","arrToStr","trimAddr","addr","path","host","user","firstSlash","indexOf","userHost","firstAt","kidToCanonUserHostPath","kidStripHostPath","JWS","constructor","rawCompact","headerB64","payloadB64","signatureB64","payload","alg","kid","tgt","iat","typ","cty","fromCompact","jws","head","JSON","parse","forJSONPayload","jsonStr","forValuePayload","stringify","setTgtIat","Date","now","setKID","verify","pubKeyHandle","algorithm","namedCurve","isValid","UNSAFEExtractPayload","catch","err","toLogFormat","protected","signature","toCompactECDSAP256","privKeyHandle","headerObj","_this2","Object","forEach","k","undefined","toSign","sign","JWK","toECDSAP256Pub","assign","use","d","importKey","toECDSAP256Priv","toECDHP256Pub","toECDHP256Priv","toAESGCMKey","randomAESGCM","rawKey","_crypto$subtle","exportKey","fromECDSAP256Pub","sigPubKey","ext","key_ops","fromECDSAP256Priv","sigPrivKey","fromECDHP256Pub","encPubKey","fromECDHP256Priv","encPrivKey","JWE","protectedB64","encryptedKey","iv","cipherText","tag","getProtected","jwe","parts","encryptECDHESP256","pub","protectedObj","generateKey","ephemeralPair","publicKey","ephemeralPubKeyJWK","enc","epk","deriveKey","privateKey","deriveKeyConcatKDFSHA256","encrypt","additionalData","encryptPBKDF2AES256GCM","password","salt","encryptDirectAES256GCM","pbkdf2","algID","apu","apv","zx","subPubInfo","round","data","offset","set","toCompact","decryptECDHEP256","priv","prot","ephemeralPublic","dataLen","decrypt","decryptPBKDF2AES256GCM","decryptDirectAES256GCM","_this3","JWT","iss","sub","id","aud","setExpire","secsAfter","secsBefore","exp","nbf","withBody","IdentityCommsResponse","raw","isError","status","IdentityCommsMessage","type","dst","srcAddr","srcKeyAddr","fromObj","obj","srcKID","srcPrivKey","IdentityMetaPublic","optSrc","identityType","clientType","version","tags","appAddress","IdentityMetaPrivate","comms","created","lastHeardDay","debugLogMakeMessage","debugLogExtractMessage","debugLogStringify","IdentityComms","ref","nixHost","nixURL","apiKeyID","apiKeySecret","apiKeyJWTAuth","address","reconnectID","defaultTTLSec","nextIDUniq","metaPublic","metaPrivate","autoFetch","knownKeys","keyStore","import","sigPrivKeyJWK","encPrivKeyJWK","skipFetch","fetchMe","reqRaw","method","authHeader","fetch","headers","req","resp","json","_nixURL","URL","hostname","register","_this4","sigKID","encPair","sigPair","curSigKID","_this5","_jwkThumbSHA256B","skipVerify","_this6","fetchRecovery","recovery","objJSON","buildRecovery","_this7","_JWE$encryptPBKDF2AES","toJSONFull","_this8","fromJSONFull","full","setRecovery","compactJWE","_JWS$forValuePayload$5","_this9","_setKID","_this10","getKnownKeys","addressJWKs","addressSigPubKey","updateSigKey","newSigPair","newEncPair","_JWS$forValuePayload$8","_this11","_setKID2","updateEncKey","_JWS$forValuePayload$10","_this12","_setKID3","updateMeta","_this13","fetchIdentityPublic","_this15","_JWS$forValuePayload$14","_setKID4","destAddr","forceFetch","destUserHost","_this16","destKeys","destKeyPfx","keyID","byID","startsWith","destKey","addKnownKeys","setKnownKeys","_this17","extractMessage","msg","_this18","srcJWKs","srcSigPubKey","msgBody","src","srcID","logObj","log","makeMessage","optValSigned","optValEncrypted","_this19","curSigPubKeyKID","dstJWKs","dstEncPubKey","_jwkThumbSHA256B2","makeMessageClear","optExtraSigned","optExtraEncrypted","makeMessageSigned","optKID","signed","optKid","makeMessageEncrypted","encrypted","makeMessagePublish","pkg","makeMessageRequest","bypassCache","noCache","_this24","sendMessages","messages","r","fetchMessages","min","max","order","limit","jwt","_this26","_JWS$forValuePayload$16","_setKID5","fetchMessageStream","onMessage","redial","canceler","retryTime","jti","_this27","_JWS$forValuePayload$18","_setKID6","maybeRetry","cancelled","reader","getReader","curData","readFunc","canceled","cancel","curChunk","newLine","console","error","read","ContentPackage","route","routeAddress","vault","vaultAddress","meta","perms","noPerms","createJWK","optName","getJWK","addJWK","skipJWKMod","jwk_ops","removeJWK","clearJWKs","keyName","valueStr","optMediaType","optExtra","_JWE$encryptDirectAES","addMeta","getMeta","removeMeta","clearMeta","Identity","msgReceiveLoopRunning","pkgListeners","clearListeners","setName","setType","publishContentPackage","pkgNoPerms","deleteContentPackage","fetchContentPackage","rslt","setTimeout","msgReceiveLoop","code","extractedMsg","pkgListenAddr","l","call","clearListenAddr","instanceOfAny","object","constructors","some","idbProxyableTypes","cursorAdvanceMethods","cursorRequestMap","WeakMap","transactionDoneMap","transactionStoreNamesMap","transformCache","reverseTransformCache","idbProxyTraps","[object Object]","prop","receiver","IDBTransaction","get","objectStoreNames","objectStore","wrap","has","IDBRequest","request","promise","unlisten","removeEventListener","success","addEventListener","IDBCursor","promisifyRequest","newValue","func","IDBDatabase","transaction","advance","continue","continuePrimaryKey","includes","args","apply","unwrap","storeNames","tx","sort","done","complete","cacheDonePromiseForTransaction","IDBObjectStore","IDBIndex","Proxy","transformCachableValue","openDB","blocked","upgrade","blocking","indexedDB","open","openPromise","event","oldVersion","newVersion","db","readMethods","writeMethods","cachedMethods","Map","getMethod","targetFuncName","useIndex","isWrite","async","storeName","store","index","shift","returnVal","oldTraps","ObjsContentPkgPerms","OCPPIdxAddr","OCPPIdxPerm","OCPPIdxContentPkgID","LatestTS","Vault","forIdentity","identity","dbName","intermediateKey","_JWE$encryptECDHESP","oldVer","newVer","txn","createObjectStore","globalPerms","createIndex","contentPkgPerms","add","getConfig","latestTS","writeLatestTS","setConfig","put","config","setAdminIdentity","setAllowGlobal","op","isAllowedGlobal","openCursor","cursor","setAllowContentPackage","isAllowedContentPackage","noGlobal","gatherContentPackagePerms","perm","processedBefore","ts","msgID","cut","secs","Number","fetchLoop","messageReceived","msgs","awaitBody","encryptedMessageReceived","signedMessageReceived","contentPackagePublishReceived","contentPackageClearReceived","contentPackageRequestReceived","warn","respondContentPackagePublish","updateContentPackagePerms","setContentPackage","respondNotAllowedContentPackage","clearContentPackageReaders","respondContentPackageClear","deleteContentPackagePerms","_this14","getContentPackage","respondNotAllowedGeneral","sendmEssages","extra","_JWE$encryptDirectAES2","_this20","row","delete","optPkg","readers","_this22","ignoreAddr","addresses","_this23","_msgs","VaultManager","vaults","bootVaults","vaultIdentities","admins","j","Client","defaultAPIKeyID","defaultAPIKeySecret","defaultAPIKeyJWT","defaultNixURL","setDefaults","vaultManager","init","getIdentitiesByType","constants","defaultIdentities","loadConfig","getIdentityByAddress","newIdentity","apiKeyJWT","storeIdentity","newContentPackage","getDefaultIdentityAddress","text","contentPkg","appIdentity","getDefaultIdentity","vaultIdentity","kidParts","decryptAll","promises","all","decrypted","addIdentity","getIdentityByName","getOrCreateIdentityByName","dontSetDefault","setDefaultIdentity","storeConfig","LocalEncryptedStore","fromPasswordKeyOrJWK","lep","startDB","identities","fullJSON","_this2$db","getAllFromIndex","objs","getFromIndex","_this6$db","_JWE$encryptDirectAES3","RecoveryAndLocalEncryptedStore","fromPassword","defaultsSet","_identity$comms","jose","stores","debug","setTo"],"mappings":"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"}