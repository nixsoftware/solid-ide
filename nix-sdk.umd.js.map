{"version":3,"file":"nix-sdk.umd.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/constants.js","../src/util.js","../src/JWS.js","../src/JWK.js","../src/JWE.js","../src/JWT.js","../src/IdentityCommsResponse.js","../src/IdentityCommsMessage.js","../src/IdentityMetaPublic.js","../src/IdentityMetaPrivate.js","../src/IdentityComms.js","../src/ContentPackage.js","../src/Identity.js","../node_modules/idb/build/esm/chunk.js","../node_modules/idb/build/esm/index.js","../src/VaultStorage.js","../src/Vault.js","../src/VaultManager.js","../src/Client.js","../src/LocalEncryptedStore.js","../src/RecoveryAndLocalEncryptedStore.js","../src/index.js"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && !check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, value);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\t_entry(_this).then(returnValue, function(error) {\n\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","\n// IdentityTypes\nexport const IdentityTypeUnknown = \"\";\nexport const IdentityTypeApp     = \"app\";\nexport const IdentityTypeGroup   = \"group\";\nexport const IdentityTypeRoute   = \"route\";\nexport const IdentityTypeUser    = \"user\";\nexport const IdentityTypeVault   = \"vault\";\n\n// JWS / JWE KID Thumb length\nexport const KIDThumbLength = 8;\n\n// Identity Msg Types\nexport const IdentityMsgType = {\n  Signed:     \"s\",\n  Encrypted:  \"e\",\n  Request:    \"r\",\n  Publish:    \"p\",\n  Clear:      \"c\",\n};\n\n// Vault Operations / Permissions\nexport const VaultOps = {\n  ContentPkgRead:    \"pr\",\n  ContentPkgWrite:   \"pw\",\n  ContentPkgControl: \"pc\",\n\n  IdentitiesRead:    \"ir\",\n  IdentitiesWrite:   \"iw\",\n  IdentitiesControl: \"ic\",\n\n  VaultRead:    \"vr\",\n  VaultWrite:   \"vw\",\n  VaultControl: \"vc\",\n};\n\nexport const JWERegex = /(ey[0-9A-Za-z_\\-]*\\.[0-9A-Za-z_\\-]*\\.[0-9A-Za-z_\\-]*\\.[0-9A-Za-z_\\-]*\\.[0-9A-Za-z_\\-]*)/g;\n","export function base64EncodeStr(str) {\n  return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function(match, p1) {\n    return String.fromCharCode('0x' + p1);\n  }));\n}\n\nexport function base64EncodeStrJWS(str) {\n  return base64EncodeStr(str).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\nexport function base64EncodeBytes(str) {\n  return btoa(str);\n}\n\nexport function base64EncodeBytesURL(str) {\n  return btoa(str).replace(/\\+/g, '-').replace(/\\//g, '_');\n}\n\nexport function base64EncodeBytesJWS(str) {\n  return base64EncodeBytes(str).replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\nexport function base64DecodeStr(str) {\n  return decodeURIComponent(atob(str).split('').map(function(c) {\n    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n  }).join(''));\n}\n\nexport function base64DecodeStrJWS(str) {\n  return base64DecodeStr(str.replace(/-/g, '+').replace(/_/g, '/'));\n}\n\nexport function base64DecodeBytes(str) {\n  return atob(str);\n}\n\nexport function base64DecodeBytesJWS(str) {\n  return base64DecodeBytes(str.replace(/-/g, '+').replace(/_/g, '/'));\n}\n\nexport function strToUtf8ArrayBuf(str) {\n  str = encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function(match, p1) {\n    return String.fromCharCode('0x' + p1);\n  });\n  return bytesToUint8ArrayBuf(str);\n}\n\nexport function strToBytes(str) {\n  return encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, function(match, p1) {\n    return String.fromCharCode('0x' + p1);\n  });\n}\n\nexport function bytesToUint8ArrayBuf(str) {\n  return bytesToUint8Array(str).buffer;\n}\n\nexport function bytesToUint8Array(str) {\n  var arr = new Uint8Array(str.length);\n  for(var i = 0; i < str.length; i++) {\n    arr[i] = str.charCodeAt(i);\n  }\n  return arr;\n}\n\nexport async function b64UUID() {\n  var array = new Uint8Array(16);\n  await crypto.getRandomValues(array);\n  return base64EncodeBytesJWS(arrToBytes(array));\n}\n\nexport function bytesToLenPrefixUint8Array(str) {\n  var arr = new Uint8Array(str.length + 4);\n  arr[0] = (str.length >>> 24) & 0xFF;\n  arr[1] = (str.length >>> 16) & 0xFF;\n  arr[2] = (str.length >>> 8 ) & 0xFF;\n  arr[3] = (str.length >>> 0 ) & 0xFF;\n  for(var i = 0; i < str.length; i++) {\n    arr[i+4] = str.charCodeAt(i);\n  }\n  return arr;\n}\n\nexport function errPromise(val) {\n  return new Promise((resolve, reject) =>\n    { reject(val); });\n}\n\nexport function successPromise(val) {\n  return new Promise((resolve, reject) =>\n    { resolve(val); });\n}\n\nexport function jwkThumbSHA256B64(jwk) {\n  if(jwk.kty !== \"EC\" || jwk.crv !== \"P-256\") {\n    return errPromise(`unsupported key - only ES256 - ${jwk.kty} ${jwk.crv}`);\n  }\n\n  return crypto.subtle.digest({name: \"SHA-256\"},\n    bytesToUint8ArrayBuf(`{\"crv\":\"P-256\",\"kty\":\"EC\",\"x\":\"${jwk.x}\",\"y\":\"${jwk.y}\"}`))\n    .then((hash) => base64EncodeBytesURL(arrToBytes(hash)));\n}\n\nexport function arrToBytes(arr) {\n  var out = '';\n  var u8arr = new Uint8Array(arr);\n  var len = u8arr.byteLength;\n  for (var i = 0; i < len; i++) {\n    out += String.fromCharCode(u8arr[i]);\n  }\n  return out;\n}\n\nexport function arrToStr(arr) {\n  return decodeURIComponent(arrToBytes(arr).split('').map(function(c) {\n    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n  }).join(''));\n}\n\nexport function trimAddr(addr) {\n  var path = \"\";\n  var host = \"\";\n  var user = \"\";\n\n  var firstSlash = addr.indexOf('/');\n  var userHost = addr;\n  if(firstSlash >= 0) {\n    userHost = addr.slice(0, firstSlash);\n    path = addr.slice(firstSlash);\n  }\n\n  var firstAt = userHost.indexOf('@');\n  user = userHost;\n  if(firstAt >= 0) {\n    user = userHost.slice(0, firstAt).replace(/=/g, '');\n    host = userHost.slice(firstAt);\n  }\n\n  // addresses without a host are asumed to be api.nix.software\n  if(host === \"@api.nix.software\") {\n    host = \"\";\n  }\n\n  return user + host + path;\n}\n\nexport function kidToCanonUserHostPath(addr) {\n  let path = '';\n  let userHost = addr;\n  let firstSlash = addr.indexOf('/');\n  if(firstSlash >= 0) {\n    userHost = addr.slice(0, firstSlash);\n    path = addr.slice(firstSlash+1);\n  }\n\n  let firstAt = userHost.indexOf('@');\n  var user = userHost;\n  var host = \"@api.nix.software\";\n  if(firstAt >= 0) {\n    user = userHost.slice(0, firstAt);\n    host = userHost.slice(firstAt);\n  }\n  // is user portion potentially unpadded? length-1 for leading type char\n  if(user.length && user[user.length-1] != '=') {\n    switch(user.length-1 % 4) {\n      case 2:\n        user += \"==\";\n        break;\n      case 3:\n        user += \"=\";\n        break;\n      default:\n        // 0, 4 have no padding\n        break;\n    }\n  }\n  return [user + host, path];\n}\n\nexport function kidStripHostPath(addr) {\n  let path = addr;\n  let firstSlash = addr.indexOf('/');\n  if(firstSlash >= 0) {\n    path = addr.slice(firstSlash+1);\n  }\n  return path;\n}\n","import {\n  base64EncodeStrJWS, base64EncodeBytesJWS,\n  base64DecodeStrJWS, base64DecodeBytesJWS,\n  bytesToUint8ArrayBuf, arrToBytes,\n  errPromise, successPromise,\n} from './util.js';\n\nexport default class JWS {\n  constructor() {\n    this.rawCompact = null;\n\n    this.headerB64    = null;\n    this.payloadB64   = null;\n    this.signatureB64 = null;\n\n    this.payload = null;\n\n    this.alg = null;\n    this.jwk = null;\n    this.kid = null;\n    this.tgt = null;\n    this.iat = 0;\n    this.typ = null;\n    this.cty = null;\n  }\n\n  static fromCompact(str) {\n    let jws = new JWS();\n    jws.rawCompact = str;\n    [jws.headerB64, jws.payloadB64, jws.signatureB64] = str.split(\".\", 3);\n    let head = JSON.parse(base64DecodeStrJWS(jws.headerB64));\n    [jws.alg, jws.jwk, jws.kid, jws.tgt, jws.iat, jws.typ, jws.cty] = \n      [head.alg, head.jwk, head.kid, head.tgt, head.iat, head.typ, head.cty];\n\n    return jws;\n  }\n\n  static forJSONPayload(jsonStr) {\n    let jws = new JWS();\n    jws.payload = jsonStr;\n    return jws;\n  }\n\n  static forValuePayload(val) {\n    return JWS.forJSONPayload(JSON.stringify(val));\n  }\n\n  setTgtIat(tgt) {\n    this.iat = (Date.now() / 1000) | 0;\n    this.tgt = tgt;\n    return this;\n  }\n\n  setKID(kid) {\n    this.kid = kid;\n    return this;\n  }\n\n  async verify(pubKeyHandle) {\n    if(this.alg !== \"ES256\") {\n      return errPromise(\"unsupported alg - only ES256 supported\");\n    }\n\n    if(pubKeyHandle.algorithm.name !== \"ECDSA\" || pubKeyHandle.algorithm.namedCurve !== \"P-256\") {\n      return errPromise(`unsupported key - only ES256 - ${JSON.stringify(pubKeyHandle.algorithm)}`);\n    }\n\n    let payload = bytesToUint8ArrayBuf(this.headerB64 + \".\" + this.payloadB64);\n    return await crypto.subtle.verify(\n      {name: \"ECDSA\", hash: {name: \"SHA-256\"}},\n      pubKeyHandle,\n      bytesToUint8ArrayBuf(base64DecodeBytesJWS(this.signatureB64)),\n      payload)\n    .then((isValid) => isValid ? successPromise(this.UNSAFEExtractPayload()) : errPromise(`signature invalid for ${JSON.stringify(this)}`))\n    .catch((err) => errPromise(err));\n  }\n\n  toLogFormat() {\n    return {\n      payload: JSON.parse(base64DecodeStrJWS(this.payloadB64)),\n      protected: JSON.parse(base64DecodeStrJWS(this.headerB64)),\n      signature: this.signatureB64,\n    };\n  }\n\n  UNSAFEExtractPayload() {\n    return base64DecodeStrJWS(this.payloadB64);\n  }\n\n  async toCompactECDSAP256(privKeyHandle) {\n    if(privKeyHandle.algorithm.name !== \"ECDSA\" || privKeyHandle.algorithm.namedCurve !== \"P-256\") {\n      return errPromise(`unsupported key - only ES256 - ${JSON.stringify(privKeyHandle.algorithm)}`);\n    }\n\n    this.alg = \"ES256\";\n\n    let headerObj = {\n      alg: this.alg,\n      jwk: this.jwk,\n      kid: this.kid,\n      tgt: this.tgt,\n      iat: this.iat,\n      typ: this.typ,\n      cty: this.cty,\n    };\n    Object.keys(headerObj).forEach(k => (!headerObj[k] && !headerObj[k] !== undefined) && delete headerObj[k]);\n    this.headerB64 = base64EncodeStrJWS(JSON.stringify(headerObj));\n\n    this.payloadB64 = base64EncodeStrJWS(this.payload);\n\n    let toSign = bytesToUint8ArrayBuf(this.headerB64 + \".\" + this.payloadB64);\n    let signature = await crypto.subtle.sign(\n      {name: \"ECDSA\", hash: {name: \"SHA-256\"}},\n      privKeyHandle,\n      toSign);\n\n    this.signatureB64 = base64EncodeBytesJWS(arrToBytes(signature));\n    return [this.headerB64, this.payloadB64, this.signatureB64].join(\".\");\n  }\n};\n","import {jwkThumbSHA256B64} from './util.js';\n\nexport default class JWK {\n  constructor() {\n    // shouldn't be called dirctly\n  }\n\n  static async toECDSAP256Pub(jwk) {\n    jwk = Object.assign({}, jwk);\n    delete jwk.use;\n    delete jwk.d;\n    return await crypto.subtle.importKey(\n      \"jwk\", jwk, {name: \"ECDSA\", namedCurve: \"P-256\"}, true, [\"verify\"]);\n  }\n\n  static async toECDSAP256Priv(jwk) {\n    jwk = Object.assign({}, jwk);\n    delete jwk.use;\n    return crypto.subtle.importKey(\n      \"jwk\", jwk, {name: \"ECDSA\", namedCurve: \"P-256\"}, true, [\"sign\"]);\n  }\n\n  static async toECDHP256Pub(jwk) {\n    jwk = Object.assign({}, jwk);\n    delete jwk.use;\n    delete jwk.d;\n    return await crypto.subtle.importKey(\n      \"jwk\", jwk, {name: \"ECDH\", namedCurve: \"P-256\"}, true, []);\n  }\n\n  static async toECDHP256Priv(jwk) {\n    jwk = Object.assign({}, jwk);\n    delete jwk.use;\n    return await crypto.subtle.importKey(\n      \"jwk\", jwk, {name: \"ECDH\", namedCurve: \"P-256\"}, true, [\"deriveKey\"]);\n  }\n\n  static async toAESGCMKey(jwk) {\n    jwk = Object.assign({}, jwk);\n    delete jwk.use;\n    return await crypto.subtle.importKey(\"jwk\", jwk, {name: \"AES-GCM\"}, true, [\"encrypt\", \"decrypt\"]);\n  }\n\n  static async randomAESGCM() {\n    const rawKey = crypto.getRandomValues(new Uint8Array(32));\n    return crypto.subtle.exportKey(\"jwk\", \n      await crypto.subtle.importKey(\"raw\", rawKey, \"AES-GCM\", true, [\"encrypt\", \"decrypt\"]));\n  }\n\n  static async fromECDSAP256Pub(key) {\n    let sigPubKey = await crypto.subtle.exportKey(\"jwk\", key);\n    delete sigPubKey.d;\n    delete sigPubKey.ext;\n    delete sigPubKey.key_ops;\n    sigPubKey.use = \"sig\";\n    sigPubKey.kid = await jwkThumbSHA256B64(sigPubKey);\n    return sigPubKey;\n  }\n\n\n  static async fromECDSAP256Priv(key) {\n    let sigPrivKey = await crypto.subtle.exportKey(\"jwk\", key);\n    delete sigPrivKey.ext;\n    delete sigPrivKey.key_ops;\n    sigPrivKey.use = \"sig\";\n    sigPrivKey.kid = await jwkThumbSHA256B64(sigPrivKey);\n    return sigPrivKey;\n  }\n\n  static async fromECDHP256Pub(key) {\n    let encPubKey = await crypto.subtle.exportKey(\"jwk\", key);\n    delete encPubKey.d;\n    delete encPubKey.ext;\n    delete encPubKey.key_ops;\n    encPubKey.use = \"enc\";\n    encPubKey.kid = await jwkThumbSHA256B64(encPubKey);\n    return encPubKey;\n  }\n\n  static async fromECDHP256Priv(key) {\n    let encPrivKey = await crypto.subtle.exportKey(\"jwk\", key);\n    delete encPrivKey.ext;\n    delete encPrivKey.key_ops;\n    encPrivKey.use = \"enc\";\n    encPrivKey.kid = await jwkThumbSHA256B64(encPrivKey);\n    return encPrivKey;\n  }\n}\n","import {\n  base64EncodeStrJWS,\n  base64EncodeBytesJWS,\n  base64DecodeStrJWS,\n  base64DecodeBytesJWS,\n  strToUtf8ArrayBuf,\n  arrToBytes,\n  arrToStr,\n  bytesToUint8ArrayBuf,\n  bytesToLenPrefixUint8Array,\n} from './util.js';\nimport JWK from './JWK.js';\n\nexport default class JWE {\n  constructor() {\n    this.protectedB64 = null;\n    this.encryptedKey = null;\n    this.iv           = null;\n    this.cipherText   = null;\n    this.tag          = null;\n    this.protectedObj = null;\n  }\n\n  getProtected() {\n    return JSON.parse(base64DecodeStrJWS(this.protectedB64));\n  }\n\n  static fromCompact(str) {\n    let jwe = new JWE();\n    let parts = str.split(\".\", 5);\n    jwe.protectedB64 = parts[0];\n    jwe.iv = bytesToUint8ArrayBuf(base64DecodeBytesJWS(parts[2]));\n    jwe.cipherText = bytesToUint8ArrayBuf(base64DecodeBytesJWS(parts[3]));\n    jwe.tag = bytesToUint8ArrayBuf(base64DecodeBytesJWS(parts[4]));\n\n    return jwe;\n  }\n\n  toLogFormat(payload) {\n    return {\n      payload: payload,\n      protected: JSON.parse(base64DecodeStrJWS(this.protectedB64)),\n    };\n  }\n\n  static async encryptECDHESP256(pub, payload, kid, protectedObj) {\n    let out = new JWE();\n\n    if(pub.algorithm.name !== \"ECDH\" || pub.algorithm.namedCurve !== \"P-256\") {\n      throw `unsupported key - only ECDH-ES P-256- ${JSON.stringify(pub.algorithm)}`;\n    }\n\n    let ephemeralPair = await crypto.subtle.generateKey(\n      {name: \"ECDH\", namedCurve: \"P-256\"}, true, [\"deriveKey\"]);\n\n    let ephemeralPubKeyJWK = await crypto.subtle.exportKey(\"jwk\", ephemeralPair.publicKey);\n    delete ephemeralPubKeyJWK.ext;\n    delete ephemeralPubKeyJWK.key_ops;\n    ephemeralPubKeyJWK.use = \"enc\";\n\n    protectedObj = protectedObj || {};\n    protectedObj.alg = \"ECDH-ES\";\n    protectedObj.enc = \"A256GCM\";\n    protectedObj.epk = ephemeralPubKeyJWK;\n\n    if(kid) {\n      protectedObj.kid = kid;\n    }\n    this.protectedObj = protectedObj;\n\n    out.protectedB64 = base64EncodeStrJWS(JSON.stringify(protectedObj));\n\n    let key = await crypto.subtle.deriveKey(\n      {name: \"ECDH\", namedCurve: \"P-256\", public: pub},\n      ephemeralPair.privateKey,\n      {name: \"AES-GCM\", length: 256},\n      true,\n      [\"encrypt\", \"decrypt\"]);\n\n    key = await JWE.deriveKeyConcatKDFSHA256(\"A256GCM\", \"\", \"\", key)\n\n    out.iv = await crypto.getRandomValues(new Uint8Array(12));\n    out.cipherText = new Uint8Array(await crypto.subtle.encrypt(\n      {name: \"AES-GCM\", iv: out.iv, additionalData: bytesToUint8ArrayBuf(out.protectedB64), tagLength: 128},\n      key,\n      strToUtf8ArrayBuf(payload)));\n\n    out.tag = out.cipherText.slice(out.cipherText.byteLength - 16);\n    out.cipherText = out.cipherText.slice(0, out.cipherText.byteLength - 16);\n\n    return out;\n  }\n\n  static async encryptPBKDF2AES256GCM(password, salt, payload, kid, protectedObj) {\n    return await JWE.encryptDirectAES256GCM(await JWE.pbkdf2(password, salt), payload, kid, protectedObj);\n  }\n\n  static async encryptDirectAES256GCM(key, payload, kid, protectedObj) {\n    let out = new JWE();\n\n    // check for JWK instead of raw key\n    if(key.kty === \"oct\") {\n      key = await JWK.toAESGCMKey(key);\n    }\n\n    if(key.algorithm.name !== \"AES-GCM\" || key.algorithm.length !== 256) {\n      throw `unsupported key - only AES-GCM 256 - ${JSON.stringify(key.algorithm)}`;\n    }\n\n    protectedObj = protectedObj || {};\n    protectedObj.alg =  \"dir\";\n    protectedObj.enc = \"A256GCM\";\n\n    if(kid) {\n      protectedObj.kid = kid;\n    }\n    this.protectedObj = protectedObj;\n\n    out.protectedB64 = base64EncodeStrJWS(JSON.stringify(protectedObj));\n\n    out.iv = await crypto.getRandomValues(new Uint8Array(12));\n\n    out.cipherText = new Uint8Array(await crypto.subtle.encrypt(\n      {name: \"AES-GCM\", iv: out.iv, additionalData: bytesToUint8ArrayBuf(out.protectedB64), tagLength: 128},\n      key,\n      strToUtf8ArrayBuf(payload)));\n\n    out.tag = out.cipherText.slice(out.cipherText.byteLength - 16);\n    out.cipherText = out.cipherText.slice(0, out.cipherText.byteLength - 16);\n\n    return out;\n  }\n\n  static async pbkdf2(password, salt) {\n    return await crypto.subtle.deriveKey(\n      {name: \"PBKDF2\", salt: strToUtf8ArrayBuf(salt), iterations: 10000, hash: {name: \"SHA-256\"}},\n      await crypto.subtle.importKey(\"raw\", strToUtf8ArrayBuf(password), {name: \"PBKDF2\"}, false, [\"deriveKey\", \"deriveBits\"]),\n      {name: \"AES-GCM\", length: 256},\n      true,\n      [\"encrypt\", \"decrypt\"]);\n  }\n\n  // algID, apu, and apv should be raw byte arrays, zx should be the ECDH output\n  static async deriveKeyConcatKDFSHA256(algID, apu, apv, zx) {\n    algID = bytesToLenPrefixUint8Array(algID);\n    apu   = bytesToLenPrefixUint8Array(apu);\n    apv   = bytesToLenPrefixUint8Array(apv);\n\n    // 256\n    let subPubInfo = new Uint8Array(4);\n    subPubInfo[0] = 0;\n    subPubInfo[1] = 0;\n    subPubInfo[2] = 1;\n    subPubInfo[3] = 0;\n\n    // 1\n    let round = new Uint8Array(4);\n    round[0] = 0;\n    round[1] = 0;\n    round[2] = 0;\n    round[3] = 1;\n\n    zx = new Uint8Array(await crypto.subtle.exportKey(\"raw\", zx));\n\n    let data = new Uint8Array(\n      round.length + zx.length + algID.length + apu.length + apv.length + subPubInfo.length);\n\n    let offset = 0;\n    data.set(round, offset);\n    offset += round.length;\n    data.set(zx, offset);\n    offset += zx.length;\n    data.set(algID, offset);\n    offset += algID.length;\n    data.set(apu, offset);\n    offset += apu.length;\n    data.set(apv, offset);\n    offset += apv.length;\n    data.set(subPubInfo, offset);\n\n    let key = await crypto.subtle.digest({name: \"SHA-256\"}, data);\n    return await crypto.subtle.importKey(\"raw\", key, {name: \"AES-GCM\"}, true, [\"encrypt\", \"decrypt\"]);\n  }\n\n  toCompact() {\n    return `${this.protectedB64}..${base64EncodeBytesJWS(arrToBytes(this.iv))}.` + \n      `${base64EncodeBytesJWS(arrToBytes(this.cipherText))}.${base64EncodeBytesJWS(arrToBytes(this.tag))}`;\n  }\n\n  async decryptECDHEP256(priv) {\n    let prot = JSON.parse(base64DecodeStrJWS(this.protectedB64));\n    if(prot.alg !== \"ECDH-ES\" || prot.enc !== \"A256GCM\") {\n      throw `unsupported alg + enc - only ECDH-ES with A256GCM - ${prot.alg} ${prot.enc}`;\n    }\n    this.protectedObj = prot;\n\n    let ephemeralPublic = await JWK.toECDHP256Pub(prot.epk);\n\n    let key = await crypto.subtle.deriveKey(\n      {name: \"ECDH\", namedCurve: \"P-256\", public: ephemeralPublic},\n      priv,\n      {name: \"AES-GCM\", length: 256},\n      true,\n      [\"encrypt\", \"decrypt\"]);\n\n    let apu = prot.apu ? base64DecodeBytesJWS(prot.apu) : \"\";\n    let apv = prot.apv ?  base64DecodeBytesJWS(prot.apv) : \"\";\n\n    key = await JWE.deriveKeyConcatKDFSHA256(\"A256GCM\", apu, apv, key)\n\n    let dataLen = this.cipherText.byteLength + this.tag.byteLength;\n    let data = new Uint8Array(dataLen);\n    data.set(new Uint8Array(this.cipherText), 0);\n    data.set(new Uint8Array(this.tag), dataLen - 16);\n\n    return arrToStr(await crypto.subtle.decrypt(\n      {name: \"AES-GCM\", iv: this.iv, additionalData: bytesToUint8ArrayBuf(this.protectedB64), tagLength: 128},\n      key,\n      data));\n  }\n\n  async decryptPBKDF2AES256GCM(password, salt) {\n    return await this.decryptDirectAES256GCM(await JWE.pbkdf2(password, salt));\n  }\n\n  async decryptDirectAES256GCM(key) {\n    // check for JWK instead of raw key\n    if(key.kty === \"oct\") {\n      key = await JWK.toAESGCMKey(key);\n    }\n\n    let prot = JSON.parse(base64DecodeStrJWS(this.protectedB64));\n    if(prot.alg !== \"dir\" || prot.enc !== \"A256GCM\") {\n      throw `unsupported alg + enc - only DIRECT with A256GCM - ${prot.alg} ${prot.enc}`;\n    }\n    this.protectedObj = prot;\n\n    let dataLen = this.cipherText.byteLength + this.tag.byteLength;\n    let data = new Uint8Array(dataLen);\n    data.set(new Uint8Array(this.cipherText), 0);\n    data.set(new Uint8Array(this.tag), dataLen - 16);\n\n    return arrToStr(await crypto.subtle.decrypt(\n      {name: \"AES-GCM\", iv: this.iv, additionalData: bytesToUint8ArrayBuf(this.protectedB64), tagLength: 128},\n      key,\n      data));\n  }\n}\n","export default class JWT {\n  constructor(iss, sub, id, aud) {\n    this.iss = iss;\n    this.sub = sub;\n    this.id  = id;\n    this.aud = aud;\n\n    // These get set if setExpire(), otherwise they are left out\n    // this.exp = null;\n    // this.nbf = null;\n    // this.iat = null;\n  }\n\n  setExpire(secsAfter, secsBefore) {\n    this.iat = (Date.now() / 1000) | 0;\n    this.exp = this.iat + secsAfter;\n    this.nbf = this.iat - secsBefore;\n    return this;\n  }\n\n  withBody(body) {\n    for(var key in body) {\n      this[key] = body[key];\n    }\n    return this;\n  }\n}\n","export default class IdentityCommsResponse {\n  constructor(raw) {\n    for(var key in raw) {\n      this[key] = raw[key];\n    }\n  }\n\n  isError() {\n    return this.status === undefined || this.status === null ||\n        this.status < 200 || this.status >= 400;\n  }\n};\n","import JWS from './JWS.js';\n\nexport default class IdentityCommsMessage {\n  constructor(type, id, dst, exp, body) {\n    this.type = type;\n    this.id = id;\n    this.dst = dst;\n    this.exp = exp;\n    this.body = body;\n\n    this.srcAddr = \"\";\n    this.srcKeyAddr = \"\";\n    this.kid = \"\";\n  }\n\n  static fromObj(obj) {\n    let out = new IdentityCommsMessage();\n    for(var key in obj) {\n      out[key] = obj[key];\n    }\n    return out;\n  }\n\n  toCompactECDSAP256(srcKID, srcPrivKey) {\n    return JWS.forValuePayload({\n      type: this.type,\n      id:   this.id, \n      dst:  this.dst,\n      exp:  this.exp,\n      body: this.body,\n    }).setKID(srcKID).toCompactECDSAP256(srcPrivKey);\n  }\n}\n","export default class IdentityMetaPublic {\n  constructor(optSrc) {\n    this.identityType = \"\";\n    this.name = \"\";\n    this.clientType = \"Web\";\n    this.version = \"v1.0.0.1\";\n    this.tags = {};\n    this.appAddress = \"\";\n\n    if(optSrc) {\n      for(var key in optSrc) {\n        this[key] = optSrc[key];\n      }\n    }\n  }\n}\n","export default class IdentityMetaPrivate {\n  constructor(optSrc) {\n    this.comms = [];\n    this.tags = {};\n    this.created = 0;\n    this.lastHeardDay = 0;\n\n    if(optSrc) {\n      for(var key in optSrc) {\n        this[key] = optSrc[key];\n      }\n    }\n  }\n}\n","import JWS from './JWS.js';\nimport JWE from './JWE.js';\nimport JWT from './JWT.js';\nimport JWK from './JWK.js';\nimport IdentityCommsResponse from './IdentityCommsResponse.js';\nimport IdentityCommsMessage from './IdentityCommsMessage.js';\nimport IdentityMetaPublic from './IdentityMetaPublic.js';\nimport IdentityMetaPrivate from './IdentityMetaPrivate.js';\n\nimport {jwkThumbSHA256B64, kidToCanonUserHostPath, kidStripHostPath, trimAddr, arrToBytes} from './util.js';\nimport {KIDThumbLength, IdentityMsgType} from './constants.js';\n\nlet debugLogMakeMessage = false;\nexport function logMakeMessage(setTo) {\n  if(setTo !== undefined) {\n    debugLogMakeMessage = setTo;\n  }\n  return debugLogMakeMessage;\n}\n\nlet debugLogExtractMessage = false;\nexport function logExtractMessage(setTo) {\n  if(setTo !== undefined) {\n    debugLogExtractMessage = setTo;\n  }\n  return debugLogExtractMessage;\n}\n\nlet debugLogStringify = true;\nexport function logStringify(setTo) {\n  if(setTo !== undefined) {\n    debugLogStringify = setTo;\n  }\n  return debugLogStringify;\n}\n\n/**\n * IdentityComms wraps the identity registration / management APIs and APIs for\n * messaging across Nix between identities. Using this class requires an API key\n * and secret or a JWT derived from an API key and secret.\n */\nexport default class IdentityComms {\n\n  /**\n   * This only partially initializes communication. If this is a new identity,\n   * it may need to be register()ed. Existing identities can be import()ed or\n   * recover()ed.\n   */\n  constructor({\n    apiKeyID      = null,\n    apiKeySecret  = null,\n    /* or */\n    apiKeyJWTAuth = null,\n\n    nixURL = \"https://api.nix.software\",\n  } = {}) {\n\n\n    this.nixHost = \"\";\n    this.nixURL = nixURL || \"https://api.nix.software\";\n\n    this.apiKeyID = apiKeyID;\n    this.apiKeySecret = apiKeySecret || apiKeyJWTAuth;\n\n    this.address     = null;\n    this.reconnectID = '' + Date.now();\n    this.sigPubKey   = null;\n    this.sigPrivKey  = null;\n    this.encPubKey   = null;\n    this.encPrivKey  = null;\n\n    this.defaultTTLSec = 7 * 24 * 60 * 60; // one week\n    this.nextIDUniq = 0;\n\n    this.metaPublic = new IdentityMetaPublic();\n    this.metaPrivate = new IdentityMetaPrivate();\n\n    this.autoFetch = true;\n\n    this.knownKeys = {};\n    this.keyStore = null;\n  }\n\n  /**\n   * Set the public and private key pairs, addres, and identityType. Fully ready for\n   * communication after this. Note that metadata is fetched.\n   */\n  async import(identityType, address, sigPrivKeyJWK, encPrivKeyJWK, skipFetch) {\n    this.metaPublic.identityType  = identityType;\n\n    this.address = address;\n    this.sigPrivKey = await JWK.toECDSAP256Priv(sigPrivKeyJWK);\n    this.sigPubKey  = await JWK.toECDSAP256Pub(sigPrivKeyJWK);\n    this.encPrivKey = await JWK.toECDHP256Priv(encPrivKeyJWK);\n    this.encPubKey  = await JWK.toECDHP256Pub(encPrivKeyJWK);\n\n    if(skipFetch) {\n      return \n    }\n\n    return await this.fetchMe();\n  }\n\n  /**\n   * internal utility function wrapping HTTP commonalitites.\n   */\n  async reqRaw(method, path, body) {\n    var authHeader = this.apiKeyID ? \n      `Basic ${btoa(this.apiKeyID + \":\" + this.apiKeySecret)}` :\n      `Bearer ${this.apiKeySecret}`;\n\n    return fetch(`${this._nixURL}${path}`, {\n      method: method,\n      cache: 'no-cache',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': authHeader,\n      },\n      redirect: 'follow',\n      body: body ? JSON.stringify(body) : undefined,\n    });\n  }\n\n  async req(method, path, body) {\n    return this.reqRaw(method, path, body).then((resp) => resp.json());\n  }\n\n  /**\n   * Setter strips trailing slashes - URI interpolation assumes paths should add\n   * the slash.\n   */\n  set nixURL(nixURL) {\n    this._nixURL = nixURL.replace(/\\/+$/, \"\");\n    this.nixHost = new URL(this._nixURL).hostname;\n  }\n\n  /**\n   * Register this identity as the optional type (otherwise existing is used).\n   * Current public metadata, private metadata, signing and encryption keys are\n   * used if set, generated if not. On success, the identity is registered and\n   * ready to use. The address will be set and should be saved for restoration.\n   * Consider making an encrypted recovery (buildRecovery() + setRecovery()).\n   */\n  async register(identityType) {\n    let path = '/v1/identity';\n\n    if(identityType) {\n      this.metaPublic.identityType = identityType;\n    }\n\n    if(!this.sigPrivKey) {\n      let sigPair = await crypto.subtle.generateKey(\n        {name: \"ECDSA\", namedCurve: \"P-256\"}, true, [\"sign\"]);\n      this.sigPrivKey = sigPair.privateKey;\n      this.sigPubKey  = sigPair.publicKey;\n    }\n\n    if(!this.encPrivKey) {\n      let encPair = await crypto.subtle.generateKey(\n        {name: \"ECDH\", namedCurve: \"P-256\"}, true, [\"deriveKey\"]);\n      this.encPrivKey = encPair.privateKey;\n      this.encPubKey  = encPair.publicKey;\n    }\n\n    let sigPubKey = await JWK.fromECDSAP256Pub(this.sigPubKey);\n    let sigKID = \"/\" + sigPubKey.kid\n    let encPubKey = await JWK.fromECDHP256Pub(this.encPubKey);\n\n    var request = {\n      sigPubKey: sigPubKey,\n      encPubKey: await JWS.forValuePayload(encPubKey)\n        .setTgtIat(`${path}#encPubKey`).setKID(sigKID)\n        .toCompactECDSAP256(this.sigPrivKey),\n      metaPublic: await JWS.forValuePayload(this.metaPublic)\n        .setTgtIat(`${path}#metaPublic`).setKID(sigKID)\n        .toCompactECDSAP256(this.sigPrivKey),\n      metaPrivate: await JWS.forValuePayload(this.metaPrivate)\n        .setTgtIat(`${path}#metaPrivate`).setKID(sigKID)\n        .toCompactECDSAP256(this.sigPrivKey),\n    }\n\n    let resp = new IdentityCommsResponse(await this.req('POST', path, request));\n\n    if(resp.isError()) {\n      return resp;\n    }\n\n    this.address = resp.body.address;\n    return resp;\n  }\n\n  async curSigKID() {\n    return `${this.address}/${await jwkThumbSHA256B64(await crypto.subtle.exportKey(\"jwk\", this.sigPubKey))}`;\n  }\n\n  /**\n   * Fetch recovery data, descrypt it with password, set the internals of this\n   * identity. Note that metadata is fetched. Identity is fully ready to use on\n   * success. With skipVerify, don't try to validate the signature around the\n   * outside. In most recovery scenarios, skipVerify=true makes sense.\n   */\n  async recover(address, password, skipVerify) {\n    let recovery = await this.fetchRecovery(address, skipVerify);\n    if(recovery.isError()) {\n      throw `couldn't fetch recovery - ${JSON.stringify(recover)}`\n    }\n\n    // if verification was supposed to occur, it already did in fetchRecovery()\n    // and succeeded\n    let objJSON = await JWE.fromCompact(\n      JSON.parse(\n        JWS.fromCompact(recovery.body.jws).UNSAFEExtractPayload()\n      ).jwe)\n      .decryptPBKDF2AES256GCM(password, address);\n\n    let obj = JSON.parse(objJSON);\n    await this.import(obj.type, obj.address, obj.sigPrivKey, obj.encPrivKey);\n    this.autoFetch = obj.autoFetch;\n\n    return await this.fetchMe();\n  }\n\n  /**\n   * Construct a JSON Web Encryption of the keys, address, and type for this\n   * identity. Note that this DOES NOT store anything anywhere. Call\n   * setRecovery() with the returned JWE string.\n   */\n  async buildRecovery(password) {\n    let sigPrivKey = await JWK.fromECDSAP256Priv(this.sigPrivKey);\n    let sigKID = \"/\" + sigPrivKey.kid\n    let encPrivKey = await JWK.fromECDHP256Priv(this.encPrivKey);\n\n    return (await JWE.encryptPBKDF2AES256GCM(\n      password,\n      this.address,\n      JSON.stringify({\n        address: this.address,\n        type: this.metaPublic.identityType,\n        sigPrivKey: sigPrivKey,\n        encPrivKey: encPrivKey,\n        autoFetch: this.autoFetch,\n      }),\n      `${this.address}`\n    )).toCompact();\n  }\n\n  /**\n   * toJSONFull renders a more detailed represenation of the identity with no\n   * encryption and the public and private metadat\n   */\n  async toJSONFull() {\n    let sigPrivKey = await JWK.fromECDSAP256Priv(this.sigPrivKey);\n    let sigKID = \"/\" + sigPrivKey.kid\n    let encPrivKey = await JWK.fromECDHP256Priv(this.encPrivKey);\n\n    return JSON.stringify({\n      nixHost: this.nixHost,\n      nixURL:  this._nixURL,\n      apiKeyID: this.apiKeyID,\n      apiKeySecret: this.apiKeySecret,\n      address: this.address,\n      sigPrivKey: sigPrivKey,\n      encPrivKey: encPrivKey,\n      autoFetch: this.autoFetch,\n      defaultTTLSec: this.defaultTTLSec,\n      metaPublic: this.metaPublic,\n      metaPrivate: this.metaPrivate,\n    });\n  }\n\n  /** \n   * A static constructur from the full JSON\n   */\n  static async fromJSONFull(json) {\n    let full = JSON.parse(json);\n    let comms = new IdentityComms({\n      apiKeyID: full.apiKeyID,\n      apiKeySecret: full.apiKeySecret,\n      nixURL: full.nixURL,\n    });\n\n    await comms.import(full.metaPublic.identityType, full.address, full.sigPrivKey, full.encPrivKey, true);\n    comms.autoFetch = full.autoFetch;\n    comms.defaultTTLSec = full.defaultTTLSec;\n    comms.metaPublic = new IdentityMetaPublic(full.metaPublic);\n    comms.metaPrivate = new IdentityMetaPrivate(full.metaPrivate);\n    return comms;\n  }\n\n  /**\n   * Given the JWE string from buildRecovery() or a JWE built otherwise\n   * containing this identity's private data, sign and store it for later\n   * recovery.  This JWE can be obtained by many other devices to attempt\n   * recovery, so use strong keys and encryption.\n   */\n  async setRecovery(compactJWE) {\n    let path = '/v1/identity/me/data/recovery';\n\n    var request = {\n      jws: await JWS.forValuePayload({\n          name: \"recovery\",\n          jwe: compactJWE,\n        }).setTgtIat(`${path}#jws`).setKID(await this.curSigKID())\n        .toCompactECDSAP256(this.sigPrivKey),\n    }\n\n    return new IdentityCommsResponse(await this.req('POST', path, request));\n  }\n\n  /**\n   * Fetch the recovery JWE for any address. With skipVerify, the signature\n   * around the JWE is not verified. In most recovery scenarios, you will not\n   * have the appropriate knowledge to do verification and skipVerify=true is\n   * reasonable.\n   */\n  async fetchRecovery(address, skipVerify) {\n    let path = `/v1/identity/${address}/data/recovery`;\n    let resp = new IdentityCommsResponse(await this.req('GET', path, null));\n    if (skipVerify) {\n      return resp;\n    }\n\n    let addressJWKs = await this.getKnownKeys(address);\n    let addressSigPubKey = await JWK.toECDSAP256Pub(addressJWKs.sigPubKey);\n\n    // throws if signature fails\n    await JWS.fromCompact(resp.body.jws).verify(addressSigPubKey);\n\n    return resp;\n  }\n\n  /**\n   * Update the signing key and include a new encryption key or resign the\n   * existing encryption key with the new signing key. If the signing key isn't\n   * given, one will be generated. The new signign key will be added to the\n   * signature chain for other idnetities to validate and update. Note that\n   * signatures over old recovery data and other long-term stored signed data\n   * may need to be updated.\n   */\n  async updateSigKey(sigPrivKeyJWK, encPrivKeyJWK) {\n    let path = '/v1/identity/me/sigPubKey';\n\n    let newSigPair = {};\n    if(sigPrivKeyJWK) {\n      newSigPair = {\n        privateKey: await JWK.toECDSAP256Priv(sigPrivKeyJWK),\n        publicKey:  await JWK.toECDSAP256Pub(sigPrivKeyJWK),\n      };\n    } else {\n      newSigPair = await crypto.subtle.generateKey(\n        {name: \"ECDSA\", namedCurve: \"P-256\"}, true, [\"sign\"]);\n    }\n\n    let newEncPair = {publicKey: this.encPubKey, privateKey: this.encPrivKey};\n    if(encPrivKeyJWK) {\n      newEncPair = {\n        privateKey: await JWK.toECDHP256Priv(encPrivKeyJWK),\n        publicKey:  await JWK.toECDSAP256Pub(encPrivKeyJWK),\n      };\n    }\n\n    let sigPubKey = await JWK.fromECDSAP256Pub(newSigPair.publicKey);\n    let encPubKey = await JWK.fromECDHP256Pub(newEncPair.publicKey);\n\n    var request = {\n      sigPubKey: await JWS.forValuePayload(sigPubKey)\n        .setTgtIat(`${path}#sigPubKey`).setKID(await this.curSigKID())\n        .toCompactECDSAP256(this.sigPrivKey),\n      encPubKey: await JWS.forValuePayload(encPubKey)\n        .setTgtIat(`${path}#encPubKey`).setKID(this.address + \"/\" + sigPubKey.kid)\n        .toCompactECDSAP256(newSigPair.privateKey),\n    }\n\n    let resp = new IdentityCommsResponse(await this.req('POST', path, request));\n\n    if(resp.isError()) {\n      return resp;\n    }\n\n    this.sigPrivKey = newSigPair.privateKey;\n    this.sigPubKey  = newSigPair.publicKey;\n    this.encPrivKey = newEncPair.privateKey;\n    this.encPubKey  = newEncPair.publicKey;\n    return resp;\n  }\n\n  /**\n   * Update the encryption key. If one isn't given, a new one will be generated.\n   * Note that you may want to update recovery data.\n   */\n  async updateEncKey(encPrivKeyJWK) {\n    let path = '/v1/identity/me/encPubKey';\n\n    let newEncPair = {};\n    if(encPrivKeyJWK) {\n      newEncPair = {\n        privateKey: await JWK.toECDHP256Priv(encPrivKeyJWK),\n        publicKey:  await JWK.toECDSAP256Pub(encPrivKeyJWK),\n      };\n    } else {\n      newEncPair = await crypto.subtle.generateKey(\n        {name: \"ECDH\", namedCurve: \"P-256\"}, true, [\"deriveKey\"]);\n    }\n\n    let encPubKey = await JWK.fromECDHP256Pub(newEncPair.publicKey);\n    var request = {\n      encPubKey: await JWS.forValuePayload(encPubKey)\n        .setTgtIat(`${path}#encPubKey`).setKID(await this.curSigKID())\n        .toCompactECDSAP256(this.sigPrivKey),\n    }\n\n    let resp = new IdentityCommsResponse(await this.req('POST', path, request));\n\n    if(resp.isError()) {\n      return resp;\n    }\n\n    this.encPrivKey = newEncPair.privateKey;\n    this.encPubKey  = newEncPair.publicKey;\n    return resp;\n  }\n\n  /**\n   * Update the public and/or private metadata for this identity. Given metadata\n   * is used if defined and the internal metadata will be replaced. Otherwise,\n   * the internal metadata is assuemd to be newer than the server and is used.\n   */\n  async updateMeta(metaPublic, metaPrivate) {\n    let path = '/v1/identity/me/meta';\n\n    metaPublic = metaPublic || this.metaPublic;\n    metaPrivate = metaPrivate || this.metaPrivate;\n\n    let curSigKID = await this.curSigKID();\n\n    var request = {\n      metaPublic: await JWS.forValuePayload(metaPublic)\n        .setTgtIat(`${path}#metaPublic`).setKID(curSigKID)\n        .toCompactECDSAP256(this.sigPrivKey),\n      metaPrivate: await JWS.forValuePayload(metaPrivate)\n        .setTgtIat(`${path}#metaPrivate`).setKID(curSigKID)\n        .toCompactECDSAP256(this.sigPrivKey),\n    }\n\n    let resp = new IdentityCommsResponse(await this.req('POST', path, request));\n\n    if(resp.isError()) {\n      return resp;\n    }\n\n    this.metaPublic = metaPublic;\n    this.metaPrivate = metaPrivate;\n    return resp;\n  }\n\n  /**\n   * Get the public keys, signature chain, and metadata about another identity.\n   */\n  async fetchIdentityPublic(address) {\n    return new IdentityCommsResponse(await this.req('GET', `/v1/identity/${address}`, null));\n  }\n\n\n  /**\n   * Get the full identity and private metadata of this identity.\n   */\n  async fetchMe() {\n    let path = '/v1/identity/me';\n\n    var request = {\n      jwt: await JWS.forValuePayload(new JWT(this.address, this.address, this.address, [this.nixHost]).setExpire(300, 300))\n        .setTgtIat(`${path}#jwt`).setKID(await this.curSigKID())\n        .toCompactECDSAP256(this.sigPrivKey),\n    }\n\n    let resp = new IdentityCommsResponse(await this.req('POST', path, request));\n\n    if(resp.isError()) {\n      return resp;\n    }\n\n    this.metaPublic = new IdentityMetaPublic(resp.body.metaPublic);\n    this.metaPrivate = new IdentityMetaPrivate(resp.body.metaPrivate);\n    return resp;\n  }\n\n  /**\n   * Get the current public signing and encryption keys for an identity if\n   * possible. These could come from the local key store, from the cache inside\n   * the IdentityComms, or from the server if autoFetch is enabled (keep in mind\n   * this means trusting Nix).\n   */\n  async getKnownKeys(destAddr, forceFetch) {\n    let [destUserHost, destKeyPfx] = kidToCanonUserHostPath(destAddr);\n\n    if((destUserHost in this.knownKeys) && !(forceFetch === true)) {\n      let destKeys = this.knownKeys[destUserHost];\n      if(!destKeyPfx) {\n        return destKeys;\n      }\n      for(var keyID in destKeys.byID) {\n        if(keyID.startsWith(destKeyPfx)) {\n          var destKey = destKeys.byID[keyID];\n          return destKey.use === 'sig' ? (\n            {sigPubKey: destKey}\n          ): (\n            {encPubKey: destKey}\n          );\n        }\n      }\n    }\n\n    if(this.keyStore && !forceFetch) {\n      try {\n        let result = this.keyStore.getKnownKeys(destAddr);\n        this.addKnownKeys(destAddr, [result.sigPubKey, result.encPubKey]);\n      } catch(e) {\n        // ignore\n      }\n    }\n\n    if(this.autoFetch || forceFetch) {\n      let resp = await this.fetchIdentityPublic(destUserHost);\n      if(!resp.isError()) {\n        let result = {\n          encPubKey: JSON.parse(JWS.fromCompact(resp.body.encPubKey).UNSAFEExtractPayload()),\n          sigPubKey: resp.body.sigPubKey,\n        };\n        this.addKnownKeys(destAddr, [result.sigPubKey, result.encPubKey]);\n\n        if(this.keyStore) {\n          this.keys.setKnownKeys(destAddr, result);\n        }\n        return result;\n      }\n    }\n\n    throw `could not find keys for ${destAddr}`;\n  }\n\n  /**\n   * add zero or more keys to the knownKeys cache - does not pass through to the\n   * keyStore.\n   */\n  async addKnownKeys(addr, keys) {\n    var [userHost] = kidToCanonUserHostPath(addr);\n    keys.map((key) => {\n      if(!key) return;\n      var path = kidStripHostPath(key.kid);\n      if(!this.knownKeys[userHost]) {\n        this.knownKeys[userHost] = {sigPubKey: null, encPubKey: null, byID: {}};\n      }\n      this.knownKeys[userHost].byID[path] = key;\n      if(key.use === \"sig\") {\n        this.knownKeys[userHost].sigPubKey = key;\n      } else if (key.use === \"enc\") {\n        this.knownKeys[userHost].encPubKey = key;\n      }\n    });\n  }\n\n  /**\n   * Validate the message signature, decrypt the message body if needed, and\n   * return the extracted results.\n   */\n  async extractMessage(msg) {\n    let jws = JWS.fromCompact(msg);\n    let srcJWKs = await this.getKnownKeys(jws.kid);\n\n    let srcSigPubKey = await JWK.toECDSAP256Pub(srcJWKs.sigPubKey);\n    let msgBody = JSON.parse(await jws.verify(srcSigPubKey));\n\n    let [srcID] = kidToCanonUserHostPath(jws.kid);\n    let jwe = null;\n    if(msgBody.body.jwe) {\n      jwe = await JWE.fromCompact(msgBody.body.jwe);\n      msgBody.body.jwe = JSON.parse(await jwe.decryptECDHEP256(this.encPrivKey));\n      if (kidToCanonUserHostPath(msgBody.body.jwe.src)[0] !== srcID) {\n        throw \"JWE src doesn't match message signature kid\";\n      }\n    }\n\n    msgBody.src = srcID;\n    msgBody.srcKID = jws.kid;\n\n    if(debugLogExtractMessage) {\n      let logObj = jws.toLogFormat();\n      if(msgBody.body.jwe) {\n        logObj.payload.body.jwe = jwe.toLogFormat(msgBody.body.jwe);\n      }\n      logObj = debugLogStringify ? JSON.stringify(logObj, null, 2) : logObj;\n      console.log(\"extractMessage\\n\", logObj);\n    }\n\n    return msgBody;\n  }\n\n  /**\n   * Generic message construction used by the other message convenience\n   * functions to build, encrypt, sign the needed parts of the message.\n   */\n  async makeMessage(type, destAddr, optValSigned, optValEncrypted) {\n    let now = (Date.now() / 1000) | 0;\n    let uniqID = this.nextIDUniq++;\n    let id = `${now}.${uniqID}`;\n    let srcAddr = trimAddr(this.address);\n\n    destAddr = trimAddr(destAddr);\n\n    let body = optValSigned || {};\n\n    let jwe = null;\n    if(optValEncrypted) {\n      optValEncrypted.src = srcAddr;\n\n      let dstJWKs = await this.getKnownKeys(destAddr);\n      let dstEncPubKey = await JWK.toECDHP256Pub(dstJWKs.encPubKey);\n\n      jwe = await JWE.encryptECDHESP256(\n        dstEncPubKey,\n        JSON.stringify(optValEncrypted),\n        `${destAddr}/${(await jwkThumbSHA256B64(dstJWKs.encPubKey)).slice(0, KIDThumbLength)}`\n      );\n\n      body.jwe = jwe.toCompact();\n    }\n\n    let curSigPubKeyKID = await jwkThumbSHA256B64(await crypto.subtle.exportKey(\"jwk\", this.sigPubKey));\n\n    let out = await (new IdentityCommsMessage(type, id, destAddr, ((Date.now() / 1000) + this.defaultTTLSec) | 0, body))\n      .toCompactECDSAP256(`${srcAddr}/${curSigPubKeyKID.slice(0, KIDThumbLength)}`, this.sigPrivKey);\n\n    if(debugLogMakeMessage) {\n      let logObj = JWS.fromCompact(out).toLogFormat();\n      if(optValEncrypted) {\n        logObj.payload.body.jwe = jwe.toLogFormat(optValEncrypted);\n      }\n      logObj = debugLogStringify ? JSON.stringify(logObj, null, 2) : logObj;\n      console.log(\"makeMessage\\n\", logObj);\n    }\n\n    return out;\n  }\n\n  /**\n   * A clear message indicates that the cache should remove any messages\n   * relevant to content package @kid and that the destination should voluntarily\n   * destroy any currently viewed or cached information relevant to the content\n   * package @kid.\n   */\n  async makeMessageClear(destAddr, kid, optExtraSigned, optExtraEncrypted) {\n    optExtraSigned = optExtraSigned || {};\n    optExtraSigned.kid = kid;\n    return this.makeMessage(IdentityMsgType.Clear, destAddr, optExtraSigned, optExtraEncrypted);\n  }\n\n  /**\n   * Signed messages have no specific meaning to the cache with respect to\n   * content packages. They are simply messages containing data for another\n   * party that can be seen but not modified by the server.\n   */\n  async makeMessageSigned(destAddr, optKID, signed) {\n    if(optKID) {\n      signed = signed || {};\n      signed.kid = optKid;\n    }\n    return this.makeMessage(IdentityMsgType.Signed, destAddr, signed, null);\n  }\n\n  /**\n   * Message encrypted has no meaning to the cache and is simple an end-to-end\n   * encrypted message.\n   */\n  async makeMessageEncrypted(destAddr, optKID, optExtraSigned, encrypted) {\n    if(optKID) {\n      optExtraSigned = optExtraSigned || {};\n      optExtraSigned.kid = optKID;\n    }\n    return this.makeMessage(IdentityMsgType.Encrypted, destAddr, optExtraSigned, encrypted);\n  }\n\n  /**\n   * Message publish is intented to publish a specific content package to the\n   * cache and recipient either for pre-caching or in response to a request.\n   */\n  async makeMessagePublish(destAddr, kid, pkg, optExtraSigned, optExtraEncrypted) {\n    optExtraSigned = optExtraSigned || {};\n    optExtraSigned.kid = kid;\n    optExtraEncrypted = optExtraEncrypted || {};\n    optExtraEncrypted.pkg= pkg;\n    return this.makeMessage(IdentityMsgType.Publish, destAddr, optExtraSigned, optExtraEncrypted);\n  }\n\n  /**\n   * Message request is intended to get a specific content package by @kid from\n   * @destAddr. If the content package has been published to cache, the response\n   * may contain the requested package; otherwise, it can be fetched later.\n   */\n  async makeMessageRequest(destAddr, kid, bypassCache, optExtraSigned, optExtraEncrypted) {\n    optExtraSigned = optExtraSigned || {};\n    optExtraSigned.kid = kid;\n    optExtraSigned.noCache = bypassCache || false;\n    optExtraSigned.encPubKey = await JWK.fromECDHP256Pub(this.encPubKey);\n    return this.makeMessage(IdentityMsgType.Request, destAddr, optExtraSigned, optExtraEncrypted);\n  }\n\n  /**\n   * Send one or more messages to one or more destinations. @messages should be\n   * an array of compact JWS messages built by the utility functions.\n   */\n  async sendMessages(messages) {\n    let resp = new IdentityCommsResponse(await this.req('POST', '/v1/messages/send', {msgs: messages}));\n    if(resp.isError()) {\n      return resp;\n    }\n    resp.body = resp.body? resp.body.map((r) => IdentityCommsMessage.fromObj(r)) : [];\n    return resp;\n  }\n\n  /**\n   * Fetch zero or more messages via polling. Min, max, order, and limit can be\n   * used for pagination with respect to the server timestamps applied to each\n   * message.\n   */\n  async fetchMessages(min, max, order, limit) {\n    let path = '/v1/messages/fetch';\n    let jwt = {};\n\n    if(min) jwt.min = min;\n    if(max) jwt.max = max;\n    if(order) jwt.order = order;\n    if(limit) jwt.limit = limit;\n\n    var request = {\n      jwt: await JWS.forValuePayload(new JWT(this.address, this.address, this.address, [this.nixHost]).setExpire(300, 300).withBody(jwt))\n        .setTgtIat(`${path}#jwt`).setKID(await this.curSigKID())\n        .toCompactECDSAP256(this.sigPrivKey),\n    }\n\n    return new IdentityCommsResponse(await this.req('POST', path, request));\n  }\n\n  /**\n   * streams messages via a POST Long Poll streaming body. for each message\n   * received, onMessage is called with the {ts, msg} body. if redial is true,\n   * errors and disconnects will result in redialing. if given, canceler should\n   * be an object with a member called cancelled that is true when this loop\n   * should end.\n   */\n  async fetchMessageStream(min, max, order, limit, onMessage, redial, canceler, retryTime) {\n    retryTime = retryTime ? 4 : retryTime * 2;\n    if(retryTime > 30000) {\n      retryTime = 30000;\n    }\n\n    let path = '/v1/messages/listen';\n    let jwt = {jti: this.reconnectID};\n\n    if(min) jwt.min = min;\n    if(max) jwt.max = max;\n    if(order) jwt.order = order;\n    if(limit) jwt.limit = limit;\n\n    var request = {\n      jwt: await JWS.forValuePayload(new JWT(this.address, this.address, this.address, [this.nixHost]).setExpire(300, 300).withBody(jwt))\n        .setTgtIat(`${path}#jwt`).setKID(await this.curSigKID())\n        .toCompactECDSAP256(this.sigPrivKey),\n    }\n\n    let maybeRetry = () => {\n      if(redial && (!canceler || !canceler.cancelled)) {\n        setTimeout(this.fetchMessageStream.bind(this, min, max, order, limit, onMessage, redial, canceler), retryTime);\n      }\n    }\n\n    this.reqRaw('POST', path, request).then(resp => {\n      const reader = resp.body.getReader();\n      let curData = '';\n\n      const readFunc = ({end, value}) => {\n        retryTime = 16;\n        if(end) {\n          maybeRetry();\n          return;\n        }\n\n        if(canceler && canceler.canceled) {\n          reader.cancel();\n          return;\n        }\n\n        let curChunk = arrToBytes(value);\n        let newLine = curChunk.indexOf('\\n');\n        while (newLine >= 0) {\n          curData += curChunk.slice(0, newLine);\n          try {\n            onMessage(JSON.parse(curData));\n          } catch(e) {\n            console.error(`identity${this.address}.fetchMessageStream() => onMessage exception`, e);\n          }\n          curData = '';\n          curChunk = curChunk.slice(newLine+1);\n          newLine = curChunk.indexOf('\\n');\n        }\n        curData += curChunk;\n        reader.read().then(readFunc).catch(maybeRetry);\n      };\n\n      reader.read().then(readFunc).catch(maybeRetry);\n    }).catch(maybeRetry);\n  }\n};\n","import JWE from './JWE.js';\nimport {trimAddr} from './util.js';\n\nexport default class ContentPackage {\n  constructor({id = null, routeAddress = null, vaultAddress = null} = {}) {\n    this.route = routeAddress;\n    this.vault = vaultAddress;\n    this.id           = id;\n\n    this.meta = {};\n    this.keys = {};\n    this.perms = {};\n  }\n\n  static async fromObj(obj) {\n    let out = new ContentPackage();\n    for(var key in obj) {\n      out[key] = obj[key];\n    }\n    out.keys = {};\n    for(var key in obj.keys) {\n      out.keys[key] = await crypto.subtle.importKey(\"jwk\", obj.keys[key], {\"name\": \"AES-GCM\"}, true, [\"encrypt\", \"decrypt\"]);\n    }\n    return out;\n  }\n\n  async noPerms() {\n    let out = {\n      route: this.route || undefined,\n      vault: this.vault || undefined,\n      id: this.id,\n\n      meta: this.meta,\n      keys: {},\n    };\n    for(var key in this.keys) {\n      out.keys[key] = await crypto.subtle.exportKey(\"jwk\", this.keys[key]);\n    }\n    return out;\n  }\n\n  async createJWK(optName) {\n    let key = await crypto.subtle.generateKey({name: \"AES-GCM\", length: 256}, true, [\"encrypt\", \"decrypt\"]);\n    if(!optName) {\n      optName = Object.keys(this.keys).length;\n      while(`${optName}` in this.keys) optName++;\n      optName = `${optName}`;\n    }\n    this.keys[optName] = key;\n\n    return this.getJWK(optName);\n  }\n\n  async addJWK(name, jwk, skipJWKMod) {\n    let key = await crypto.subtle.importKey(\"jwk\", jwk, {\"name\": \"AES-GCM\"}, true, [\"encrypt\", \"decrypt\"]);\n    this.keys[name] = key;\n\n    if (skipJWKMod) {\n      return;\n    }\n\n    jwk.use = \"enc\";\n    let route = this.route || this.vault || \"\";\n    jwk.kid = `${trimAddr(route)}/${this.id}/${name}`;\n    if(this.route && this.vault) {\n      jwk.vault = trimAddr(this.vault);\n    }\n    return this;\n  }\n\n  async getJWK(name) {\n    name = name.split(\"/\");\n    name = name[name.length-1];\n\n    if(!(name in this.keys)) {\n      return null;\n    }\n\n    let jwk = await crypto.subtle.exportKey(\"jwk\", this.keys[name]);\n    delete jwk.ext;\n    delete jwk.jwk_ops;\n    jwk.use = \"enc\";\n    let route = this.route || this.vault || \"\";\n    jwk.kid = `${trimAddr(route)}/${this.id}/${name}`;\n    if(this.route && this.vault) {\n      jwk.vault = trimAddr(this.vault);\n    }\n    return jwk;\n  }\n\n  removeJWK(name) {\n    delete this.keys[name];\n  }\n\n  clearJWKs() {\n    this.keys = {};\n  }\n\n  async encrypt(keyName, valueStr, optMediaType, optExtra) {\n    if(!(typeof(valueStr) === \"string\" || valueStr instanceof String)) {\n      throw `value isn't a string - did you forget to encode?`;\n    }\n\n    keyName = keyName.split(\"/\");\n    keyName = keyName[keyName.length-1];\n\n    if(!(keyName in this.keys)) {\n      throw `no key named \"${keyName}\" found`;\n    }\n\n    let route = this.route || this.vault || \"\";\n    let kid = `${trimAddr(route)}/${this.id}/${keyName}`;\n    let protectedObj = optExtra || {};\n    if(this.route && this.vault) {\n      protectedObj.vault = trimAddr(this.vault);\n    }\n    if(optMediaType) {\n      protectedObj.typ = optMediaType;\n    }\n\n    let rslt = (await JWE.encryptDirectAES256GCM(this.keys[keyName], valueStr, kid, protectedObj)).toCompact();\n    return rslt;\n  }\n\n  async decrypt(compactJWE) {\n    let jwe = JWE.fromCompact(compactJWE);\n    let protectedObj = jwe.getProtected();\n    let parts = protectedObj.kid.split(\"/\");\n    let keyName = parts[parts.length-1];\n    let jwk = await this.getJWK(keyName);\n    if(!jwk) {\n      throw `content package ${this.id} does not have a key ${keyName} for this encrypted data`;\n    }\n    return await jwe.decryptDirectAES256GCM(jwk);\n  }\n\n  addMeta(key, value) {\n    if(!(typeof(key) === \"string\" || key instanceof String)) {\n      throw \"metadata keys must be strings\";\n    }\n    if(!(typeof(value) === \"string\" || value instanceof String)) {\n      throw \"metadata values must be strings\";\n    }\n    this.meta[key] = value;\n    return this;\n  }\n\n  getMeta(key) {\n    return this.meta[key];\n  }\n\n  removeMeta(key) {\n    delete this.meta[key];\n  }\n\n  clearMeta(key) {\n    this.meta = {};\n  }\n}\n","import IdentityComms from './IdentityComms.js';\nimport ContentPackage from './ContentPackage.js';\nimport {b64UUID} from './util.js';\nimport {IdentityMsgType} from './constants.js';\nimport {kidToCanonUserHostPath} from './util.js';\nimport JWK from './JWK.js';\n\nexport default class Identity {\n  constructor({comms = null} = {}) {\n    this.comms = comms;\n    this.msgReceiveLoopRunning = false;\n    this.pkgListeners = {};\n    this.clearListeners = {};\n  }\n\n  static async fromJSONFull(json) {\n    let comms = await IdentityComms.fromJSONFull(json);\n    return new Identity({comms: comms});\n  }\n\n  async toJSONFull() {\n    return this.comms.toJSONFull();\n  }\n\n  get address() {\n    return this.comms.address;\n  }\n\n  get name() {\n    return this.comms.metaPublic.name;\n  }\n\n  async setName(name) {\n    return this.comms.metaPublic.name = name;\n  }\n\n  get type() {\n    return this.comms.metaPublic.identityType;\n  }\n\n  async setType(type) {\n    return this.comms.metaPublic.identityType = type;\n  }\n\n  async getSigPubJWK() {\n    return await JWK.fromECDSAP256Pub(this.comms.sigPubKey);\n  }\n\n  async getEncPubJWK() {\n    return await JWK.fromECDHP256Pub(this.comms.encPubKey);\n  }\n\n  async publishContentPackage(destAddr, pkg) {\n    let pkgNoPerms = await pkg.noPerms();\n    let msg = await this.comms.makeMessagePublish(destAddr, pkg.id, pkgNoPerms, null, {perms: pkg.perms});\n    return await this.comms.sendMessages([msg]);\n  }\n\n  async deleteContentPackage(destAddr, kid) {\n    let msg = await this.comms.makeMessageClear(destAddr, kid);\n    return await this.comms.sendMessages([msg]);\n  }\n\n  async fetchContentPackage(destAddr, kid) {\n    let msg = await this.comms.makeMessageRequest(destAddr, kid);\n    let rslt = await this.comms.sendMessages([msg]);\n    if(rslt.code < 20000 || rslt.code > 29999) {\n      throw(rslt.err);\n    }\n    if(rslt.body[0].code === 20016) {\n      let extractedMsg = await this.comms.extractMessage(rslt.body[0].body[0].msg);\n      return await ContentPackage.fromObj(extractedMsg.body.jwe.pkg);\n    }\n    if(!this.msgReceiveLoopRunning) {\n      setTimeout(this.msgReceiveLoop.bind(this), 5);\n    }\n    return new Promise((resolve, reject) => {\n      [destAddr] = kidToCanonUserHostPath(destAddr);\n      this.pkgListeners[destAddr + \"/\" + kid] = {call: resolve};\n    });\n  }\n\n  async msgReceiveLoop() {\n    this.msgReceiveLoopRunning = true;\n    try {\n      this.comms.fetchMessageStream(null, null, null, null, (msgBody) => {\n        this.comms.extractMessage(msgBody.msg).then((extractedMsg) => {\n          switch(extractedMsg.type) {\n\n            case IdentityMsgType.Publish:\n              if(!extractedMsg.body.jwe || !extractedMsg.body.jwe.pkg) {\n                return;\n              }\n\n              var [src] = kidToCanonUserHostPath(extractedMsg.src);\n              let pkgListenAddr = src + \"/\" + extractedMsg.body.kid;\n              let pkgListeners = this.pkgListeners[pkgListenAddr];\n              if(pkgListeners) {\n                ContentPackage.fromObj(extractedMsg.body.jwe.pkg).then((pkg) => {\n                  pkgListeners.map((l) => {\n                    l.call(pkg, extractedMsg);\n                  });\n                });\n              }\n              delete this.pkgListeners[pkgListenAddr];\n              return;\n\n            case IdentityMsgType.Clear:\n              var [src] = kidToCanonUserHostPath(extractedMsg.src);\n              let clearListenAddr = src + \"/\" + extractedMsg.body.kid;\n              let clearListeners = this.clearListeners[clearListenAddr];\n              if(clearListeners) clearListeners.map((l) => {\n                l.call(extractedMsg.body.kid, extractedMsg);\n              });\n              delete this.clearListeners[clearListenAddr];\n              return;\n          }\n        }).catch((err) => console.error(\"processing err\", err));\n      }, true);\n    } finally {\n      this.msgReceiveLoopRunning = false;\n    }\n  }\n}\n","const instanceOfAny = (object, constructors) => constructors.some(c => object instanceof c);\n\nlet idbProxyableTypes;\r\nlet cursorAdvanceMethods;\r\n// This is a function to prevent it throwing up in node environments.\r\nfunction getIdbProxyableTypes() {\r\n    return idbProxyableTypes ||\r\n        (idbProxyableTypes = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]);\r\n}\r\n// This is a function to prevent it throwing up in node environments.\r\nfunction getCursorAdvanceMethods() {\r\n    return cursorAdvanceMethods || (cursorAdvanceMethods = [\r\n        IDBCursor.prototype.advance,\r\n        IDBCursor.prototype.continue,\r\n        IDBCursor.prototype.continuePrimaryKey,\r\n    ]);\r\n}\r\nconst cursorRequestMap = new WeakMap();\r\nconst transactionDoneMap = new WeakMap();\r\nconst transactionStoreNamesMap = new WeakMap();\r\nconst transformCache = new WeakMap();\r\nconst reverseTransformCache = new WeakMap();\r\nfunction promisifyRequest(request) {\r\n    const promise = new Promise((resolve, reject) => {\r\n        const unlisten = () => {\r\n            request.removeEventListener('success', success);\r\n            request.removeEventListener('error', error);\r\n        };\r\n        const success = () => {\r\n            resolve(wrap(request.result));\r\n            unlisten();\r\n        };\r\n        const error = () => {\r\n            reject(request.error);\r\n            unlisten();\r\n        };\r\n        request.addEventListener('success', success);\r\n        request.addEventListener('error', error);\r\n    });\r\n    promise.then((value) => {\r\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\r\n        // (see wrapFunction).\r\n        if (value instanceof IDBCursor) {\r\n            cursorRequestMap.set(value, request);\r\n        }\r\n        // Catching to avoid \"Uncaught Promise exceptions\"\r\n    }).catch(() => { });\r\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\r\n    // is because we create many promises from a single IDBRequest.\r\n    reverseTransformCache.set(promise, request);\r\n    return promise;\r\n}\r\nfunction cacheDonePromiseForTransaction(tx) {\r\n    // Early bail if we've already created a done promise for this transaction.\r\n    if (transactionDoneMap.has(tx))\r\n        return;\r\n    const done = new Promise((resolve, reject) => {\r\n        const unlisten = () => {\r\n            tx.removeEventListener('complete', complete);\r\n            tx.removeEventListener('error', error);\r\n            tx.removeEventListener('abort', error);\r\n        };\r\n        const complete = () => {\r\n            resolve();\r\n            unlisten();\r\n        };\r\n        const error = () => {\r\n            reject(tx.error);\r\n            unlisten();\r\n        };\r\n        tx.addEventListener('complete', complete);\r\n        tx.addEventListener('error', error);\r\n        tx.addEventListener('abort', error);\r\n    });\r\n    // Cache it for later retrieval.\r\n    transactionDoneMap.set(tx, done);\r\n}\r\nlet idbProxyTraps = {\r\n    get(target, prop, receiver) {\r\n        if (target instanceof IDBTransaction) {\r\n            // Special handling for transaction.done.\r\n            if (prop === 'done')\r\n                return transactionDoneMap.get(target);\r\n            // Polyfill for objectStoreNames because of Edge.\r\n            if (prop === 'objectStoreNames') {\r\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\r\n            }\r\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\r\n            if (prop === 'store') {\r\n                return receiver.objectStoreNames[1] ?\r\n                    undefined : receiver.objectStore(receiver.objectStoreNames[0]);\r\n            }\r\n        }\r\n        // Else transform whatever we get back.\r\n        return wrap(target[prop]);\r\n    },\r\n    has(target, prop) {\r\n        if (target instanceof IDBTransaction && (prop === 'done' || prop === 'store'))\r\n            return true;\r\n        return prop in target;\r\n    },\r\n};\r\nfunction addTraps(callback) {\r\n    idbProxyTraps = callback(idbProxyTraps);\r\n}\r\nfunction wrapFunction(func) {\r\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\r\n    // only create one new func per func.\r\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\r\n    if (func === IDBDatabase.prototype.transaction &&\r\n        !('objectStoreNames' in IDBTransaction.prototype)) {\r\n        return function (storeNames, ...args) {\r\n            const tx = func.call(unwrap(this), storeNames, ...args);\r\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\r\n            return wrap(tx);\r\n        };\r\n    }\r\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\r\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\r\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\r\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\r\n    // undefined if the end of the cursor has been reached.\r\n    if (getCursorAdvanceMethods().includes(func)) {\r\n        return function (...args) {\r\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\r\n            // the original object.\r\n            func.apply(unwrap(this), args);\r\n            return wrap(cursorRequestMap.get(this));\r\n        };\r\n    }\r\n    return function (...args) {\r\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\r\n        // the original object.\r\n        return wrap(func.apply(unwrap(this), args));\r\n    };\r\n}\r\nfunction transformCachableValue(value) {\r\n    if (typeof value === 'function')\r\n        return wrapFunction(value);\r\n    // This doesn't return, it just creates a 'done' promise for the transaction,\r\n    // which is later returned for transaction.done (see idbObjectHandler).\r\n    if (value instanceof IDBTransaction)\r\n        cacheDonePromiseForTransaction(value);\r\n    if (instanceOfAny(value, getIdbProxyableTypes()))\r\n        return new Proxy(value, idbProxyTraps);\r\n    // Return the same value back if we're not going to transform it.\r\n    return value;\r\n}\r\nfunction wrap(value) {\r\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\r\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\r\n    if (value instanceof IDBRequest)\r\n        return promisifyRequest(value);\r\n    // If we've already transformed this value before, reuse the transformed value.\r\n    // This is faster, but it also provides object equality.\r\n    if (transformCache.has(value))\r\n        return transformCache.get(value);\r\n    const newValue = transformCachableValue(value);\r\n    // Not all types are transformed.\r\n    // These may be primitive types, so they can't be WeakMap keys.\r\n    if (newValue !== value) {\r\n        transformCache.set(value, newValue);\r\n        reverseTransformCache.set(newValue, value);\r\n    }\r\n    return newValue;\r\n}\r\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { wrap as a, addTraps as b, instanceOfAny as c, reverseTransformCache as d, unwrap as e };\n","import { a as wrap, b as addTraps } from './chunk.js';\nexport { e as unwrap, a as wrap } from './chunk.js';\n\n/**\r\n * Open a database.\r\n *\r\n * @param name Name of the database.\r\n * @param version Schema version.\r\n * @param callbacks Additional callbacks.\r\n */\r\nfunction openDB(name, version, { blocked, upgrade, blocking } = {}) {\r\n    const request = indexedDB.open(name, version);\r\n    const openPromise = wrap(request);\r\n    if (upgrade) {\r\n        request.addEventListener('upgradeneeded', (event) => {\r\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction));\r\n        });\r\n    }\r\n    if (blocked)\r\n        request.addEventListener('blocked', () => blocked());\r\n    if (blocking)\r\n        openPromise.then(db => db.addEventListener('versionchange', blocking));\r\n    return openPromise;\r\n}\r\n/**\r\n * Delete a database.\r\n *\r\n * @param name Name of the database.\r\n */\r\nfunction deleteDB(name, { blocked } = {}) {\r\n    const request = indexedDB.deleteDatabase(name);\r\n    if (blocked)\r\n        request.addEventListener('blocked', () => blocked());\r\n    return wrap(request).then(() => undefined);\r\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\r\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\r\nconst cachedMethods = new Map();\r\nfunction getMethod(target, prop) {\r\n    if (!(target instanceof IDBDatabase &&\r\n        !(prop in target) &&\r\n        typeof prop === 'string'))\r\n        return;\r\n    if (cachedMethods.get(prop))\r\n        return cachedMethods.get(prop);\r\n    const targetFuncName = prop.replace(/FromIndex$/, '');\r\n    const useIndex = prop !== targetFuncName;\r\n    const isWrite = writeMethods.includes(targetFuncName);\r\n    if (\r\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\r\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\r\n        !(isWrite || readMethods.includes(targetFuncName)))\r\n        return;\r\n    const method = async function (storeName, ...args) {\r\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\r\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\r\n        let target = tx.store;\r\n        if (useIndex)\r\n            target = target.index(args.shift());\r\n        const returnVal = target[targetFuncName](...args);\r\n        if (isWrite)\r\n            await tx.done;\r\n        return returnVal;\r\n    };\r\n    cachedMethods.set(prop, method);\r\n    return method;\r\n}\r\naddTraps(oldTraps => ({\r\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\r\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\r\n}));\n\nexport { openDB, deleteDB };\n","import {openDB} from 'idb';\nimport JWE from './JWE.js';\nimport JWK from './JWK.js';\nimport {kidToCanonUserHostPath} from './util.js';\n\nconst ObjsIdentities = \"identities\";\nconst OIIdxAddr = \"addr\";\n\n// TODO - sign permissions?\nconst ObjsGlobalPerms = \"globalPerms\";\nconst OGPIdxAddr = \"addr\";\nconst OGPIdxPerm = \"perm\";\n\n// TODO - sign permissions?\nconst ObjsContentPkgPerms = \"contentPkgPerms\";\nconst OCPPIdxAddr      = \"addr\";\nconst OCPPIdxPerm         = \"perm\";\nconst OCPPIdxContentPkgID = \"kid\";\n\nconst ObjsContentPkgs = \"contentPkgs\";\nconst OCPIdxContentPkgID  = \"kid\";\n\nconst ObjsConfigs     = \"configs\";\nconst OCIdxKey        = \"key\";\nconst IntermediateKey = \"intermediateKey\";\nconst LatestTS        = \"latestTS\";\n\nconst ObjsKnownMsgIDs = \"knownMsgIDs\";\nconst OKMIIdxID       = \"id\";\n\nexport default class VaultStorage {\n  constructor() {\n    // do nothing because we need async\n  }\n\n  static async forIdentity({\n    identity = null,\n\n    /* optional */\n    dbName = null,\n  } = {}) {\n    let vault = new VaultStorage();\n    vault.identity = identity;\n    // TODO set ourselves as the identity comm's key store\n\n    if(!dbName) {\n      dbName = `nix.${identity.address}`;\n    }\n\n    // need to do this here for upgrade - async inside upgrade can break the txn\n    let intermediateKey = (await JWE.encryptECDHESP256(\n      vault.identity.comms.encPubKey, JSON.stringify(await JWK.randomAESGCM()), IntermediateKey\n    )).toCompact();\n\n    vault.db = await openDB(dbName, 1, {\n      upgrade(db, oldVer, newVer, txn) {\n        if(!oldVer || oldVer < 1) {\n          const identities = db.createObjectStore(ObjsIdentities, {\n            keyPath: OIIdxAddr,\n          });\n\n          const globalPerms = db.createObjectStore(ObjsGlobalPerms, {\n            keyPath: 'id',\n            autoIncrement: true,\n          });\n          globalPerms.createIndex(OGPIdxAddr, OGPIdxAddr);\n          globalPerms.createIndex(OGPIdxPerm, OGPIdxPerm);\n\n          const contentPkgPerms = db.createObjectStore(ObjsContentPkgPerms, {\n            keyPath: 'id',\n            autoIncrement: true,\n          });\n          contentPkgPerms.createIndex(OCPPIdxAddr, OCPPIdxAddr);\n          contentPkgPerms.createIndex(OCPPIdxPerm, OCPPIdxPerm);\n          contentPkgPerms.createIndex(OCPPIdxContentPkgID, OCPPIdxContentPkgID);\n\n          const contentPkgs = db.createObjectStore(ObjsContentPkgs, {\n            keyPath: OCPIdxContentPkgID,\n          });\n\n          const knownMsgIDs = db.createObjectStore(ObjsKnownMsgIDs, {\n            keyPath: OKMIIdxID,\n          });\n\n          const configs = db.createObjectStore(ObjsConfigs, {\n            keyPath: OCIdxKey,\n          });\n\n          configs.add({[OCIdxKey]: IntermediateKey, value: intermediateKey});\n        }\n      },\n    });\n\n    intermediateKey = await vault.db.get(ObjsConfigs, IntermediateKey);\n\n    try {\n      vault.key = await JWK.toAESGCMKey(JSON.parse(await JWE.fromCompact(intermediateKey.value).\n          decryptECDHEP256(vault.identity.comms.encPrivKey)));\n    } catch(e) {\n      throw \"given key / password / jwk could not be used to unlock the store: \"  + e;\n    }\n\n    vault.latestTS = await vault.getConfig(LatestTS);\n    vault.writeLatestTS = null;\n\n    return vault;\n  }\n\n  async setConfig(key, value) {\n      value = (await JWE.encryptDirectAES256GCM(this.key, value)).toCompact();\n      return this.db.put(ObjsConfigs, {[OCIdxKey]: key, value: value});\n  }\n\n  async getConfig(key) {\n      let config = await this.db.get(ObjsConfigs, key);\n      if(!config || !config.value) {\n        return null;\n      }\n      return await JWE.fromCompact(config.value).decryptDirectAES256GCM(this.key);\n  }\n\n  async setAllowGlobal(addr, op) {\n    [addr] = kidToCanonUserHostPath(addr);\n    if(!(await this.isAllowedGlobal(addr, op))) {\n      return this.db.put(ObjsGlobalPerms, {[OGPIdxAddr]: addr, [OGPIdxPerm]: op});\n    }\n  }\n\n  async isAllowedGlobal(addr, op) {\n    [addr] = kidToCanonUserHostPath(addr);\n    const index  = this.db.transaction(ObjsGlobalPerms).store.index(OGPIdxAddr);\n    let cursor = await index.openCursor(addr);\n    while(cursor) {\n      if (cursor.value[OGPIdxPerm] === op) {\n        return true;\n      }\n      cursor = await cursor.continue();\n    }\n    return false;\n  }\n\n  async setAllowContentPackage(addr, op, kid) {\n    [addr] = kidToCanonUserHostPath(addr);\n    if(!(await this.isAllowedContentPackage(addr, op, kid, true))) {\n      return this.db.put(ObjsContentPkgPerms, {[OCPPIdxAddr]: addr, [OCPPIdxPerm]: op, [OCPPIdxContentPkgID]: kid});\n    }\n  }\n\n  async isAllowedContentPackage(addr, op, kid, noGlobal) {\n    if ((!noGlobal) && (await this.isAllowedGlobal(addr, op))) {\n      return true;\n    }\n\n    [addr] = kidToCanonUserHostPath(addr);\n    const index  = this.db.transaction(ObjsContentPkgPerms).store.index(OCPPIdxContentPkgID);\n    let cursor = await index.openCursor(kid);\n    while(cursor) {\n      if (cursor.value[OCPPIdxPerm] === op && cursor.value[OCPPIdxAddr] === addr) {\n        return true;\n      }\n      cursor = await cursor.continue();\n    }\n    return false;\n  }\n\n  async gatherContentPackagePerms(kid) {\n    const index  = this.db.transaction(ObjsContentPkgPerms).store.index(OCPPIdxContentPkgID);\n    let cursor = await index.openCursor(kid);\n    let perms = {};\n    while(cursor) {\n      let perm = cursor.value[OCPPIdxPerm];\n      let addr = cursor.value[OCPPIdxAddr];\n      if(!perms[perm]) {\n        perms[perm] = [];\n      }\n      perms[perm].push(addr);\n      cursor = await cursor.continue();\n    }\n    return perms;\n  }\n\n  async processedBefore(ts, msgID) {\n    let cut = ts.length - 9;\n    let secs = ts.slice(0, cut);\n    this.latestTS = (Number(secs) - (2 * 60) | 0) + ts.slice(cut);\n\n    let obj = await this.db.get(ObjsKnownMsgIDs, ts + msgID);\n    if(obj && obj[OKMIIdxID]) {\n      return true;\n    }\n\n    await this.db.put(ObjsKnownMsgIDs, {[OKMIIdxID]: ts + msgID});\n\n    if(!this.writeLatestTS) {\n      this.writeLatestTS = setTimeout(() => {\n        this.setConfig(LatestTS, this.latestTS).then(() => {});\n        this.writeLatestTS = null;\n      }, 1000);\n    }\n    return false;\n  }\n\n  getLatestTS() {\n    return this.latestTS\n  }\n\n  async setContentPackage(kid, pkg) {\n    let value = (await JWE.encryptDirectAES256GCM(this.key, pkg)).toCompact();\n    return this.db.put(ObjsContentPkgs, {[OCPIdxContentPkgID]: kid, value: value});\n  }\n\n  async getContentPackage(kid) {\n    let row = await this.db.get(ObjsContentPkgs, kid);\n    if(!row || !row.value) {\n      return null;\n    }\n    return await JWE.fromCompact(row.value).decryptDirectAES256GCM(this.key);\n  }\n\n  async deleteContentPackage(kid, pkg) {\n    return this.db.delete(ObjsContentPkgs, kid);\n  }\n\n  async whichIdentitiesCan(op, kid) {\n    var addresses = {};\n\n    let index  = this.db.transaction(ObjsGlobalPerms).store.index(OGPIdxPerm);\n    let cursor = await index.openCursor(op);\n    while(cursor) {\n      addresses[cursor.value[OGPIdxAddr]] = true;\n      cursor = await cursor.continue();\n    }\n\n    index  = this.db.transaction(ObjsContentPkgPerms).store.index(OCPPIdxContentPkgID);\n    cursor = await index.openCursor(kid);\n    while(cursor) {\n      if(cursor.value[OCPPIdxPerm] === op) {\n        addresses[cursor.value[OCPPIdxAddr]] = true;\n      }\n      cursor = await cursor.continue();\n    }\n\n    return Object.keys(addresses);\n  }\n\n  async deleteContentPackagePerms(kid, pkg) {\n    const index  = this.db.transaction(ObjsContentPkgPerms, 'readwrite').store.index(OCPPIdxContentPkgID);\n    let cursor = await index.openCursor(kid);\n    while(cursor) {\n      await cursor.delete();\n      cursor = await cursor.continue();\n    }\n  }\n}\n","import {openDB} from 'idb';\nimport JWE from './JWE.js';\nimport JWK from './JWK.js';\nimport {IdentityMsgType, VaultOps} from './constants.js';\nimport {kidToCanonUserHostPath} from './util.js';\nimport VaultStorage from './VaultStorage.js';\n\nexport default class Vault {\n  constructor() {\n    // do nothing because we need async\n  }\n\n  static async forIdentity({\n    identity = null,\n\n    /* optional */\n    storage = null,\n  } = {}) {\n    let vault = new Vault();\n    vault.identity = identity;\n    // TODO set ourselves as the identity comm's key store\n\n    if(!storage) {\n      storage = await VaultStorage.forIdentity({identity: identity});\n    }\n\n    vault.storage = storage;\n\n    return vault;\n  }\n\n  async setAdminIdentity(identity) {\n    // TODO store identity locallty\n    for(var key in VaultOps) {\n      await this.storage.setAllowGlobal(identity.address, VaultOps[key]);\n    }\n  }\n\n  async fetchLoop() {\n    // Step 1 - catchup\n    const limit = 10;\n    let msgs = [];\n    do {\n      msgs = await this.identity.comms.fetchMessages(this.storage.getLatestTS(), null, \"DESC\", limit);\n      for(let i = 0; i < msgs.length; i++) {\n        await this.messageReceived(msgs[i]);\n      }\n    } while(msgs.length >= limit);\n    // Step 2 - enter streaming\n    this.identity.comms.fetchMessageStream(this.storage.getLatestTS(), null, null, null, (msg) => {\n      try {\n        this.messageReceived(msg).then(()=>{});\n      } catch(err) {\n        console.log(\"Vault: error processing msg:\", msg, \"err:\", err);\n      }\n    });\n  }\n\n  async messageReceived(msgBody) {\n    // the comms class extracting the message validates the that identity is\n    // known and the message is authentic. further processing will decide\n    // whether the operation is allowed.\n    let extractedMsg = await this.identity.comms.extractMessage(msgBody.msg);\n\n    if(await this.storage.processedBefore(msgBody.ts, extractedMsg.id)) {\n      return;\n    }\n\n    switch(extractedMsg.type) {\n      case IdentityMsgType.Encrypted:\n        return this.encryptedMessageReceived(extractedMsg);\n      case IdentityMsgType.Signed:\n        return this.signedMessageReceived(extractedMsg);\n      case IdentityMsgType.Publish:\n        return this.contentPackagePublishReceived(extractedMsg);\n      case IdentityMsgType.Clear:\n        return this.contentPackageClearReceived(extractedMsg);\n      case IdentityMsgType.Request:\n        return this.contentPackageRequestReceived(extractedMsg);\n    }\n    throw `Unhandled message type ${extractedMsg.type}`;\n  }\n\n  async signedMessageReceived(msg) {\n    console.warn(\"not implemented :-D\");\n  }\n\n  async encryptedMessageReceived(msg) {\n    console.warn(\"not implemented :-D\");\n  }\n\n  async contentPackagePublishReceived(msg) {\n    if(!(await this.storage.isAllowedContentPackage(msg.src, VaultOps.ContentPkgRead, msg.body.kid))) {\n        return this.respondNotAllowedContentPackage(msg.id, msg.src,  VaultOps.ContentPkgRead, msg.body.kid);\n    }\n\n    if (msg.body.jwe.pkg) {\n      if(!(await this.storage.isAllowedContentPackage(msg.src, VaultOps.ContentPkgWrite, msg.body.kid))) {\n        return this.respondNotAllowedContentPackage(msg.id, msg.src,  VaultOps.ContentPkgWrite, msg.body.kid);\n      }\n    }\n    // may be allowed to write content packages (or this one in particular), but\n    // not to modify permissions\n    if (msg.body.jwe.perms && Object.keys(msg.body.jwe.perms).length > 0) {\n      if(!(await this.storage.isAllowedContentPackage(msg.src, VaultOps.ContentPkgControl, msg.body.kid))) {\n        return this.respondNotAllowedContentPackage(msg.id, msg.src,  VaultOps.ContentPkgControl, msg.body.kid);\n      }\n    } else if (await this.storage.isAllowedContentPackage(msg.src, VaultOps.ContentPkgControl, msg.body.kid)) {\n      msg.body.jwe.perms = await this.storage.gatherContentPackagePerms(msg.body.kid);\n    }\n\n    if (msg.body.jwe.pkg) {\n      await this.storage.setContentPackage(msg.body.kid, msg.body.jwe.pkg);\n    }\n\n    if (msg.body.jwe.perms) {\n      await this.updateContentPackagePerms(msg.body.kid, msg.body.jwe.perms, msg.body.jwe.pkg);\n    }\n\n    return this.respondContentPackagePublish(msg.id, msg.src, msg.body.kid, msg.body.jwe.pkg, msg.body.jwe.perms);\n  }\n\n  async contentPackageClearReceived(msg) {\n    if(!(await this.storage.isAllowedContentPackage(msg.src, VaultOps.ContentPkgWrite, msg.body.kid))) {\n      return this.respondNotAllowedContentPackage(msg.id, msg.src,  VaultOps.ContentPkgWrite, msg.body.kid);\n    }\n\n    await this.storage.deleteContentPackage(msg.body.kid);\n\n      await this.clearContentPackageReaders(msg.body.kid);\n\n    // may be allowed to write content packages (or this one in particular), but\n    // not to modify permissions. if allowed, delete all permissions\n    if(await this.storage.isAllowedContentPackage(msg.src, VaultOps.ContentPkgControl, msg.body.kid)) {\n      await this.storage.deleteContentPackagePerms(msg.body.kid);\n    }\n\n    return this.respondContentPackageClear(msg.id, msg.src, msg.body.kid);\n  }\n\n  async contentPackageRequestReceived(msg) {\n    if(!(await this.storage.isAllowedContentPackage(msg.src, VaultOps.ContentPkgRead, msg.body.kid))) {\n      return this.respondNotAllowedContentPackage(msg.id, msg.src,  VaultOps.ContentPkgRead, msg.body.kid);\n    }\n\n    let pkg = await this.storage.getContentPackage(msg.body.kid);\n    return this.respondContentPackagePublish(msg.id, msg.src, msg.body.kid, pkg);\n  }\n\n  async respondNotAllowedGeneral(msgID, addr, op) {\n    let msg = await this.identity.comms.makeMessageEncrypted(addr, undefined, {respTo: msgID}, {status: 401});\n    await this.identity.comms.sendmEssages([msg]);\n  }\n\n  async respondNotAllowedContentPackage(msgID, addr, op, kid) {\n    let msg = await this.identity.comms.makeMessageEncrypted(addr, kid, {respTo: msgID}, {status: 401});\n    await this.identity.comms.sendMessages([msg]);\n  }\n\n  async respondContentPackagePublish(msgID, addr, kid, pkg, perms) {\n    let extra = {respTo: msgID}\n    if(perms) {\n      extra.perms = perms;\n    }\n    let msg = await this.identity.comms.makeMessagePublish(addr, kid, pkg, extra);\n    await this.identity.comms.sendMessages([msg]);\n  }\n\n  async respondContentPackageClear(msgID, addr, kid) {\n    let msg = await this.identity.comms.makeMessageClear(addr, kid, {respTo: msgID});\n    await this.identity.comms.sendMessages([msg]);\n  }\n\n  async updateContentPackagePerms(kid, perms, optPkg) {\n    if(!optPkg) {\n      optPkg = await this.storage.getContentPackage(kid);\n    }\n\n    // TODO - redo, diff existing, use batches, etc.\n    let readers = perms[VaultOps.ContentPkgRead];\n    for(var i in readers) {\n      await this.storage.setAllowContentPackage(readers[i], VaultOps.ContentPkgRead, kid);\n      await this.respondContentPackagePublish(undefined, readers[i], kid, optPkg);\n    }\n    // TODO complete diff new status against existing, generate clear messages,\n    // publish messages, etc.\n    console.warn(\"not implemented :-D\");\n  }\n\n  async clearContentPackageReaders(kid, ignoreAddr) {\n    var addresses = await this.storage.whichIdentitiesCan(VaultOps.ContentPkgRead, kid);\n    var msgs = [];\n    for(var i in addresses) {\n      if(addresses[i] === ignoreAddr) {\n        continue;\n      }\n\n      msgs.push(await this.identity.comms.makeMessageClear(addresses[i], kid));\n      if(msgs.length >= 8) {\n        await this.identity.comms.sendMessages(msgs.slice(0, 8));\n        msgs = msgs.slice(8);\n      }\n    }\n\n    await this.identity.comms.sendMessages(msgs);\n  }\n}\n","import Vault from './Vault.js';\nimport VaultStorage from './VaultStorage.js';\n\nexport default class VaultManager {\n  constructor(vaultStorage) {\n    this.vaults = {};\n    this.vaultStorage = vaultStorage || VaultStorage;\n  }\n\n  async bootVaults(vaultIdentities, admins) {\n    for(let i = 0; i < vaultIdentities.length; i++) {\n      let storage = await this.vaultStorage.forIdentity({identity: vaultIdentities[i]});\n      let vault = await Vault.forIdentity({identity: vaultIdentities[i], storage: storage});\n      for(var j in admins) {\n        if(!admins[j]) {\n          continue;\n        }\n        await vault.setAdminIdentity(admins[j]);\n      }\n      await vault.fetchLoop();\n      this.vaults[vaultIdentities[i].address] = vault;\n    }\n  }\n}\n","import * as constants from './constants.js';\nimport {b64UUID} from './util.js';\nimport IdentityComms from './IdentityComms.js';\nimport Identity from './Identity.js';\nimport ContentPackage from './ContentPackage.js';\nimport VaultManager from './VaultManager.js';\nimport JWE from './JWE.js';\n\nexport default class Client {\n  constructor({\n    defaultAPIKeyID     = null,\n    defaultAPIKeySecret = null,\n    /* or */\n    defaultAPIKeyJWT    = null,\n\n    defaultNixURL = \"https://api.nix.software\",\n\n    store      = null,\n    vaultStore = null,\n  } = {}) {\n    this.defaultAPIKeyID     = defaultAPIKeyID;\n    this.defaultAPIKeySecret = defaultAPIKeySecret;\n    this.defaultAPIKeyJWT    = defaultAPIKeyJWT;\n    this.defaultNixURL       = defaultNixURL;\n    this.store = store;\n    this.vaultStore = vaultStore;\n    if(!this.store) {\n      throw \"store must be given - there is no default\";\n    }\n\n    if(this.store.setDefaults) {\n      this.store.setDefaults({\n        defaultAPIKeyID:     this.defaultAPIKeyID,\n        defaultAPIKeySecret: this.defaultAPIKeySecret,\n        defaultAPIKeyJWT:    this.defaultAPIKeyJWT,\n        defaultNixURL:       this.defaultNixURL,\n      })\n    }\n    this.vaultManager = new VaultManager(vaultStore);\n  }\n\n  async init() {\n    this.defaultAPIKeyID     = this.defaultAPIKeyID || await this.store.loadConfig(\"defaultAPIKeyID\");\n    this.defaultAPIKeySecret = this.defaultAPIKeySecret || await this.store.loadConfig(\"defaultAPIKeySecret\");\n    this.defaultAPIKeyJWT    = this.defaultAPIKeyJWT || await this.store.loadConfig(\"defaultAPIKeyJWT\");\n    if(!this.defaultAPIKeyJWT && !(this.defaultAPIKeyID && this.defaultAPIKeySecret)) {\n      throw \"an API key ID and secret or JWT is required\";\n    }\n\n    this.defaultNixURL = this.defaultNixURL || await this.store.loadConfig(\"defaultAPIKeyID\");\n    if(!this.defaultNixURL) {\n      throw \"a defaultNixURL is required\";\n    }\n\n    this.defaultIdentities = {\n      [constants.IdentityTypeUnknown] : null,\n      [constants.IdentityTypeApp]     : null,\n      [constants.IdentityTypeGroup]   : null,\n      [constants.IdentityTypeRoute]   : null,\n      [constants.IdentityTypeUser]    : null,\n      [constants.IdentityTypeVault]   : null,\n    }\n\n    for(var type in this.defaultIdentities) {\n      let address = await this.store.loadConfig(`defaultIdentities.${type}`)\n      if(!address) {\n        continue;\n      }\n      let identity = await this.store.getIdentityByAddress(address);\n      this.defaultIdentities[type] = identity;\n    }\n\n    let vaults = await this.store.getIdentitiesByType(constants.IdentityTypeVault);\n    await this.vaultManager.bootVaults(vaults, [\n      this.defaultIdentities[constants.IdentityTypeApp],\n      this.defaultIdentities[constants.IdentityTypeUser],\n    ]);\n\n    return this;\n  }\n\n  async newIdentity({\n    type = constants.IdentityTypeUnknown,\n    name = \"\",\n    apiKeyID = \"\",\n    apiKeySecret = \"\",\n    apiKeyJWT = \"\",\n    nixURL = \"\"} = {}) {\n\n    let comms = new IdentityComms({\n      apiKeyID:     apiKeyID     || this.defaultAPIKeyID, \n      apiKeySecret: apiKeySecret || this.defaultAPIKeySecret, \n      apiKeyJWT:    apiKeyJWT    || this.defaultAPIKeyJWT, \n      nixURL:       nixURL       || this.defaultNixURL, \n    });\n\n    comms.metaPublic.name = name;\n    comms.metaPublic.identityType = type;\n\n    await comms.register(type);\n    let identity = new Identity({comms: comms});\n    await this.store.storeIdentity(identity)\n    if(type === constants.IdentityTypeVault) {\n      this.vaultManager.bootVaults([identity], [\n        this.defaultIdentities[constants.IdentityTypeApp],\n        this.defaultIdentities[constants.IdentityTypeUser],\n      ]);\n    }\n    return identity;\n  }\n\n  async newContentPackage(id) {\n    if(!id) {\n      id = await b64UUID();\n    }\n    return new ContentPackage({\n      id: id,\n      routeAddress: this.getDefaultIdentityAddress(constants.IdentityTypeRoute),\n      vaultAddress: this.getDefaultIdentityAddress(constants.IdentityTypeVault),\n    });\n  }\n\n  async encrypt(text) {\n    let contentPkg = await this.newContentPackage();\n    let jwk = await contentPkg.createJWK();\n    let cipherText = await contentPkg.encrypt(jwk.kid, text);\n    let appIdentity = this.getDefaultIdentity(constants.IdentityTypeApp);\n    let vaultIdentity = this.getDefaultIdentity(constants.IdentityTypeVault);\n    await appIdentity.publishContentPackage(vaultIdentity.address, contentPkg);\n    return cipherText;\n  }\n\n  async decrypt(compactJWE) {\n    let jwe = JWE.fromCompact(compactJWE);\n    let protectedObj = jwe.getProtected();\n    let kidParts = protectedObj.kid.split(\"/\");\n    let address = kidParts[0];\n    let kid = kidParts[1];\n    let appIdentity = this.getDefaultIdentity(constants.IdentityTypeApp);\n    let pkg = await appIdentity.fetchContentPackage(address, kid);\n    return await pkg.decrypt(compactJWE);\n  }\n\n  async decryptAll(text) {\n    let parts = text.split(constants.JWERegex);\n    let promises = [];\n    for(var i = 1; i < parts.length; i += 2) {\n      promises.push(this.decrypt(parts[i]));\n    }\n    let decrypted = await Promise.all(promises);\n    for(var i = 1; i < parts.length; i += 2) {\n      parts[i] = decrypted[(i-1)/2];\n    }\n    return parts.join('');\n  }\n\n  async addIdentity(identity) {\n    await this.store.storeIdentity(identity)\n  }\n\n  async getIdentityByName(name) {\n    return this.store.getIdentityByName(name)\n  }\n\n  async getOrCreateIdentityByName(name, type, dontSetDefault) {\n    let identity = await this.getIdentityByName(name);\n    if(!identity) {\n      identity = await this.newIdentity({name: name, type: type});\n      if(!dontSetDefault) {\n        await this.setDefaultIdentity(identity);\n      }\n    }\n    return identity;\n  }\n\n  async getIdentityByAddress(address) {\n    return this.store.getIdentityByAddress(address)\n  }\n\n  async setDefaultIdentity(identity) {\n    await this.store.storeIdentity(identity)\n    await this.store.storeConfig(`defaultIdentities.${identity.type}`, identity.address);\n    this.defaultIdentities[identity.type] = identity;\n  }\n\n  getDefaultIdentity(type) {\n    return this.defaultIdentities[type];\n  }\n\n  getDefaultIdentityAddress(type) {\n    let identity = this.getDefaultIdentity(type);\n    return identity ? identity.address : null;\n  }\n}\n","import JWE from './JWE.js';\nimport JWK from './JWK.js';\nimport {openDB} from 'idb';\nimport Identity from './Identity.js';\n\n// DB constants\nconst ObjsIdentities = \"identities\";\n\nconst KeyAddress = \"address\";\nconst IdxName = \"name\";\nconst IdxType = \"type\";\n\nconst ObjsConfigs = \"configs\";\nconst Key = \"key\";\n\nconst IntermediateKey      = \"intermediateKey\";\n\nexport default class LocalEncryptedStore {\n  /**\n   * SHOULD NOT BE USED DIRECTLY - call fromPasswordKeyOrJWK()\n   */\n  constructor() {}\n\n  static async fromPasswordKeyOrJWK({\n    /* one of these three must be given */\n    password = null,\n    key      = null,\n    jwk      = null,\n\n    optName = \"nix.localEncryptedStore\",\n  } = {}) {\n    let lep  = new LocalEncryptedStore();\n\n    lep.dbName = optName;\n    lep.key = key;\n    if(password) {\n      lep.key = await JWE.pbkdf2(password, \"jweStore\");\n    }\n    if(jwk) {\n      lep.key = await JWK.toAESGCMKey(lep.jwk);\n    }\n\n    // note that the \"key\" is only used to decrypt the intermediate key in the\n    // datastore to allow changing this outer key without re-encrypting the\n    // entire DB\n    if(!lep.key) {\n      throw \"key, password, or JWK is required\";\n    }\n    if(lep.key.algorithm.name !== \"AES-GCM\" || lep.key.algorithm.length !== 256) {\n      throw `unsupported key - only AES-GCM 256 - ${JSON.stringify(lep.key.algorithm)}`;\n    }\n\n    return lep.startDB();\n  }\n\n  async startDB() {\n    this.dbName = this.dbName || \"nix.localEncryptedStore\";\n\n    // need to do this here for upgrade - async inside upgrade can break the txn\n    let intermediateKey = (await JWE.encryptDirectAES256GCM(this.key, JSON.stringify(await JWK.randomAESGCM()), IntermediateKey)).toCompact();\n\n    this.db = await openDB(this.dbName, 1, {\n      upgrade(db, oldVer, newVer, txn) {\n        if(!oldVer || oldVer < 1) {\n          const identities = db.createObjectStore(ObjsIdentities, {\n            keyPath: KeyAddress,\n          });\n          identities.createIndex(IdxName, IdxName);\n          identities.createIndex(IdxType, IdxType);\n\n          const configs = db.createObjectStore(ObjsConfigs, {\n            keyPath: Key,\n          });\n          configs.add({key: IntermediateKey, value: intermediateKey});\n        }\n      },\n    });\n\n    intermediateKey = await this.db.get(ObjsConfigs, IntermediateKey);\n\n    try {\n      this.key = await JWK.toAESGCMKey(JSON.parse(await JWE.fromCompact(intermediateKey.value).decryptDirectAES256GCM(this.key)));\n    } catch(e) {\n      throw \"given key / password / jwk could not be used to unlock the store: \"  + e;\n    }\n\n    return this;\n  }\n\n  async storeIdentity(identity) {\n    let fullJSON =  await identity.toJSONFull();\n    return this.db.put(ObjsIdentities, {\n      [KeyAddress]: identity.address,\n      [IdxName]:    identity.name,\n      [IdxType]:    identity.type,\n      JWE:   (await JWE.encryptDirectAES256GCM(\n        this.key, fullJSON, identity.address)).toCompact(),\n    })\n  }\n\n  async getIdentitiesByType(type) {\n    let objs = await this.db.getAllFromIndex(ObjsIdentities, IdxType, type);\n    if(!objs) {\n      return null;\n    }\n    let out = [];\n    for(let i = 0; i < objs.length; i++) {\n      let fullJSON = await JWE.fromCompact(objs[i].JWE).decryptDirectAES256GCM(this.key);\n      out.push(await Identity.fromJSONFull(fullJSON));\n    }\n    return out;\n  }\n\n  async getIdentityByName(name) {\n    let obj = await this.db.getFromIndex(ObjsIdentities, IdxName, name);\n    if(!obj || !obj.JWE) {\n      return null;\n    }\n    let fullJSON = await JWE.fromCompact(obj.JWE).decryptDirectAES256GCM(this.key);\n    return Identity.fromJSONFull(fullJSON);\n  }\n\n  async getIdentityByAddress(address) {\n    let obj = await this.db.get(ObjsIdentities, address);\n    if(!obj || !obj.JWE) {\n      return null;\n    }\n    let fullJSON = await JWE.fromCompact(obj.JWE).decryptDirectAES256GCM(this.key);\n    return Identity.fromJSONFull(fullJSON);\n  }\n\n  async storeConfig(key, val) {\n    return this.db.put(ObjsConfigs, {\n      [Key]: key,\n      JWE:   (await JWE.encryptDirectAES256GCM(\n        this.key, JSON.stringify(val), key)).toCompact(),\n    })\n  }\n\n  async loadConfig(key) {\n    let obj = await this.db.get(ObjsConfigs, key);\n    if(!obj || !obj.JWE) {\n      return null;\n    }\n    let json = await JWE.fromCompact(obj.JWE).decryptDirectAES256GCM(this.key);\n    return JSON.parse(json);\n  }\n}\n","import JWE from './JWE.js';\nimport LocalEncryptedStore from './LocalEncryptedStore.js';\nimport IdentityComms from './IdentityComms.js';\nimport Identity from './Identity.js';\n\nexport default class RecoveryAndLocalEncryptedStore extends LocalEncryptedStore {\n  /**\n   * SHOULD NOT BE USED DIRECTLY - call fromPasswordKeyOrJWK()\n   */\n  constructor() {\n    super();\n  }\n\n  static async fromPassword(password) {\n    let lep  = new RecoveryAndLocalEncryptedStore();\n\n    if(!password) {\n      throw \"password is required\";\n    }\n\n    lep.password = password;\n    lep.key = await JWE.pbkdf2(password, \"jweStore\");\n\n    return lep.startDB();\n  }\n\n  setDefaults({\n    defaultAPIKeyID     = null,\n    defaultAPIKeySecret = null,\n    defaultAPIKeyJWT    = null,\n    defaultNixURL       = null,\n  } = {}) {\n    this.defaultAPIKeyID     = defaultAPIKeyID;\n    this.defaultAPIKeySecret = defaultAPIKeySecret;\n    this.defaultAPIKeyJWT    = defaultAPIKeyJWT;\n    this.defaultNixURL       = defaultNixURL;\n    this.defaultsSet         = true;\n  }\n\n  async storeIdentity(identity) {\n    await identity.comms.setRecovery(await identity.comms.buildRecovery(this.password));\n    return LocalEncryptedStore.prototype.storeIdentity.call(this, identity);\n  }\n\n  async getIdentityByAddress(address) {\n    let identity = await LocalEncryptedStore.prototype.getIdentityByAddress.call(this, address);\n    if(identity) {\n      return identity;\n    }\n    if(!this.defaultsSet) {\n      return null;\n    }\n\n    try {\n      let comms = new IdentityComms({\n        apiKeyID:     this.defaultAPIKeyID, \n        apiKeySecret: this.defaultAPIKeySecret, \n        apiKeyJWT:    this.defaultAPIKeyJWT, \n        nixURL:       this.defaultNixURL, \n      });\n\n      await comms.recover(address, this.password, true);\n      return new Identity({comms: comms});\n    } catch(e) {\n      return null;\n    }\n\n    return null;\n  }\n}\n\n","import Client from './Client.js';\n\nimport ContentPackage from './ContentPackage.js';\n\nimport Identity              from './Identity.js';\nimport IdentityComms         from './IdentityComms.js';\nimport {logMakeMessage, logExtractMessage} from './IdentityComms.js';\nimport IdentityCommsMessage  from './IdentityCommsMessage.js';\nimport IdentityCommsResponse from './IdentityCommsResponse.js';\n\nimport IdentityMetaPublic  from './IdentityMetaPublic.js';\nimport IdentityMetaPrivate from './IdentityMetaPrivate.js';\n\nimport JWE from './JWE.js';\nimport JWS from './JWS.js';\nimport JWK from './JWK.js';\nimport JWT from './JWT.js';\n\nimport LocalEncryptedStore from './LocalEncryptedStore.js';\nimport RecoveryAndLocalEncryptedStore from './RecoveryAndLocalEncryptedStore.js';\n\nimport * as constants from './constants.js';\nimport * as util from './util.js';\n\n\nlet jose = {\n    JWE,\n    JWS,\n    JWK,\n    JWT,\n};\n\nlet stores = {\n  LocalEncryptedStore,\n  RecoveryAndLocalEncryptedStore,\n};\n\nlet debug = {\n  logMakeMessage,\n  logExtractMessage,\n};\n\nexport {\n  Client,\n\n  ContentPackage,\n\n  Identity,\n  IdentityComms,\n  IdentityCommsMessage,\n  IdentityCommsResponse,\n\n  IdentityMetaPrivate,\n  IdentityMetaPublic,\n\n  jose,\n  stores,\n\n  constants,\n  util,\n  debug,\n};\n"],"names":["_Pact","prototype","then","onFulfilled","onRejected","result","state","this","s","callback","_settle","v","e","o","_this","value","pact","bind","observer","_isSettledPact","thenable","_forTo","array","body","check","reject","i","_cycle","length","_forIn","target","keys","key","push","_for","test","update","stage","shouldContinue","updateValue","_resumeAfterTest","_resumeAfterBody","_resumeAfterUpdate","_catch","recover","Symbol","iterator","asyncIterator","const","IdentityTypeUnknown","IdentityTypeApp","IdentityTypeGroup","IdentityTypeRoute","IdentityTypeUser","IdentityTypeVault","KIDThumbLength","IdentityMsgType","Signed","Encrypted","Request","Publish","Clear","VaultOps","ContentPkgRead","ContentPkgWrite","ContentPkgControl","IdentitiesRead","IdentitiesWrite","IdentitiesControl","VaultRead","VaultWrite","VaultControl","JWERegex","b64UUID","Uint8Array","crypto","getRandomValues","base64EncodeBytesJWS","arrToBytes","base64EncodeStr","str","btoa","encodeURIComponent","replace","match","p1","String","fromCharCode","base64EncodeStrJWS","base64EncodeBytes","base64EncodeBytesURL","base64DecodeStr","decodeURIComponent","atob","split","map","c","charCodeAt","toString","slice","join","base64DecodeStrJWS","base64DecodeBytes","base64DecodeBytesJWS","strToUtf8ArrayBuf","bytesToUint8ArrayBuf","bytesToUint8Array","buffer","arr","bytesToLenPrefixUint8Array","errPromise","val","Promise","resolve","successPromise","jwkThumbSHA256B64","jwk","kty","crv","subtle","digest","name","hash","out","u8arr","len","byteLength","arrToStr","trimAddr","addr","path","host","user","firstSlash","indexOf","userHost","firstAt","kidToCanonUserHostPath","kidStripHostPath","JWS","constructor","rawCompact","headerB64","payloadB64","signatureB64","payload","alg","kid","tgt","iat","typ","cty","fromCompact","jws","head","JSON","parse","forJSONPayload","jsonStr","forValuePayload","stringify","setTgtIat","Date","now","setKID","verify","pubKeyHandle","algorithm","namedCurve","isValid","UNSAFEExtractPayload","catch","err","toLogFormat","protected","signature","toCompactECDSAP256","privKeyHandle","headerObj","_this2","Object","forEach","k","undefined","toSign","sign","JWK","toECDSAP256Pub","assign","use","d","importKey","toECDSAP256Priv","toECDHP256Pub","toECDHP256Priv","toAESGCMKey","randomAESGCM","rawKey","_crypto$subtle","exportKey","fromECDSAP256Pub","sigPubKey","ext","key_ops","fromECDSAP256Priv","sigPrivKey","fromECDHP256Pub","encPubKey","fromECDHP256Priv","encPrivKey","JWE","protectedB64","encryptedKey","iv","cipherText","tag","protectedObj","getProtected","jwe","parts","encryptECDHESP256","pub","generateKey","ephemeralPair","publicKey","ephemeralPubKeyJWK","enc","epk","deriveKey","privateKey","deriveKeyConcatKDFSHA256","encrypt","additionalData","encryptPBKDF2AES256GCM","password","salt","encryptDirectAES256GCM","pbkdf2","algID","apu","apv","zx","subPubInfo","round","data","offset","set","toCompact","decryptECDHEP256","priv","prot","_this3","ephemeralPublic","dataLen","decrypt","decryptPBKDF2AES256GCM","_this4","decryptDirectAES256GCM","_this5","JWT","iss","sub","id","aud","setExpire","secsAfter","secsBefore","exp","nbf","withBody","IdentityCommsResponse","raw","isError","status","IdentityCommsMessage","type","dst","srcAddr","srcKeyAddr","fromObj","obj","srcKID","srcPrivKey","IdentityMetaPublic","optSrc","identityType","clientType","version","tags","appAddress","IdentityMetaPrivate","comms","created","lastHeardDay","debugLogMakeMessage","debugLogExtractMessage","debugLogStringify","IdentityComms","ref","nixHost","nixURL","apiKeyID","apiKeySecret","apiKeyJWTAuth","address","reconnectID","defaultTTLSec","nextIDUniq","metaPublic","metaPrivate","autoFetch","knownKeys","keyStore","import","sigPrivKeyJWK","encPrivKeyJWK","skipFetch","fetchMe","reqRaw","method","authHeader","fetch","headers","req","resp","json","_nixURL","URL","hostname","register","sigKID","encPair","sigPair","curSigKID","_jwkThumbSHA256B","skipVerify","_this6","fetchRecovery","recovery","objJSON","buildRecovery","_this7","_JWE$encryptPBKDF2AES","toJSONFull","_this8","fromJSONFull","full","setRecovery","compactJWE","_JWS$forValuePayload$5","_this9","_setKID","_this10","getKnownKeys","addressJWKs","addressSigPubKey","updateSigKey","newSigPair","newEncPair","_JWS$forValuePayload$8","_this11","_setKID2","updateEncKey","_JWS$forValuePayload$10","_this12","_setKID3","updateMeta","_this13","fetchIdentityPublic","_this15","_JWS$forValuePayload$14","_setKID4","destAddr","forceFetch","destUserHost","_this16","destKeys","destKeyPfx","keyID","byID","startsWith","destKey","addKnownKeys","setKnownKeys","_this17","extractMessage","msg","_this18","srcJWKs","srcSigPubKey","msgBody","src","srcID","logObj","log","makeMessage","optValSigned","optValEncrypted","_this19","curSigPubKeyKID","dstJWKs","dstEncPubKey","_jwkThumbSHA256B2","makeMessageClear","optExtraSigned","optExtraEncrypted","makeMessageSigned","optKID","signed","optKid","makeMessageEncrypted","encrypted","makeMessagePublish","pkg","makeMessageRequest","bypassCache","noCache","_this24","sendMessages","messages","r","fetchMessages","min","max","order","limit","jwt","_this26","_JWS$forValuePayload$16","_setKID5","fetchMessageStream","onMessage","redial","canceler","retryTime","jti","_this27","_JWS$forValuePayload$18","_setKID6","maybeRetry","cancelled","reader","getReader","curData","readFunc","canceled","cancel","curChunk","newLine","console","error","read","ContentPackage","route","routeAddress","vault","vaultAddress","meta","perms","noPerms","createJWK","optName","getJWK","addJWK","skipJWKMod","jwk_ops","removeJWK","clearJWKs","keyName","valueStr","optMediaType","optExtra","_JWE$encryptDirectAES","addMeta","getMeta","removeMeta","clearMeta","Identity","msgReceiveLoopRunning","pkgListeners","clearListeners","setName","setType","getSigPubJWK","getEncPubJWK","publishContentPackage","pkgNoPerms","deleteContentPackage","fetchContentPackage","rslt","setTimeout","msgReceiveLoop","code","extractedMsg","pkgListenAddr","l","call","clearListenAddr","instanceOfAny","object","constructors","some","idbProxyableTypes","cursorAdvanceMethods","cursorRequestMap","WeakMap","transactionDoneMap","transactionStoreNamesMap","transformCache","reverseTransformCache","idbProxyTraps","[object Object]","prop","receiver","IDBTransaction","get","objectStoreNames","objectStore","wrap","has","IDBRequest","request","promise","unlisten","removeEventListener","success","addEventListener","IDBCursor","promisifyRequest","newValue","func","IDBDatabase","transaction","advance","continue","continuePrimaryKey","includes","args","apply","unwrap","storeNames","tx","sort","done","complete","cacheDonePromiseForTransaction","IDBObjectStore","IDBIndex","Proxy","transformCachableValue","openDB","blocked","upgrade","blocking","indexedDB","open","openPromise","event","oldVersion","newVersion","db","readMethods","writeMethods","cachedMethods","Map","getMethod","targetFuncName","useIndex","isWrite","async","storeName","store","index","shift","returnVal","oldTraps","ObjsContentPkgPerms","OCPPIdxAddr","OCPPIdxPerm","OCPPIdxContentPkgID","LatestTS","VaultStorage","forIdentity","identity","dbName","intermediateKey","_JWE$encryptECDHESP","oldVer","newVer","txn","createObjectStore","globalPerms","createIndex","contentPkgPerms","add","getConfig","latestTS","writeLatestTS","setConfig","put","config","setAllowGlobal","op","isAllowedGlobal","openCursor","cursor","setAllowContentPackage","isAllowedContentPackage","noGlobal","gatherContentPackagePerms","perm","processedBefore","ts","msgID","cut","secs","Number","getLatestTS","setContentPackage","_JWE$encryptDirectAES2","getContentPackage","row","delete","whichIdentitiesCan","addresses","deleteContentPackagePerms","Vault","storage","setAdminIdentity","fetchLoop","messageReceived","msgs","awaitBody","encryptedMessageReceived","signedMessageReceived","contentPackagePublishReceived","contentPackageClearReceived","contentPackageRequestReceived","warn","respondContentPackagePublish","updateContentPackagePerms","respondNotAllowedContentPackage","clearContentPackageReaders","respondContentPackageClear","respondNotAllowedGeneral","sendmEssages","extra","optPkg","readers","ignoreAddr","_msgs","VaultManager","vaultStorage","vaults","bootVaults","vaultIdentities","admins","j","Client","defaultAPIKeyID","defaultAPIKeySecret","defaultAPIKeyJWT","defaultNixURL","vaultStore","setDefaults","vaultManager","init","getIdentitiesByType","constants","defaultIdentities","loadConfig","getIdentityByAddress","newIdentity","apiKeyJWT","storeIdentity","newContentPackage","getDefaultIdentityAddress","text","contentPkg","appIdentity","getDefaultIdentity","vaultIdentity","kidParts","decryptAll","promises","all","decrypted","addIdentity","getIdentityByName","getOrCreateIdentityByName","dontSetDefault","setDefaultIdentity","storeConfig","LocalEncryptedStore","fromPasswordKeyOrJWK","lep","startDB","identities","fullJSON","_this2$db","getAllFromIndex","objs","getFromIndex","_this6$db","_JWE$encryptDirectAES3","RecoveryAndLocalEncryptedStore","fromPassword","defaultsSet","_identity$comms","jose","stores","debug","setTo"],"mappings":"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"}